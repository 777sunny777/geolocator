{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///geolocator.min.js","webpack:///webpack/bootstrap 5ca6fc4ba6e64a61be9c","webpack:///./src/index.js","webpack:///./src/core/geolocator.js","webpack:///./src/lib/utils.js","webpack:///./src/lib/fetch.js","webpack:///./src/core/geo.helper.js","webpack:///./src/core/enums.js","webpack:///./src/core/geo.error.js","webpack:///./src/core/geo.watcher.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_geolocator","_geolocator2","_classCallCheck","instance","Constructor","TypeError","invalidOriginOrDest","value","_utils2","isString","isArray","isPlainObject","getXHRResponse","err","xhr","_geo4","create","Code","REQUEST_FAILED","response","safeJsonParse","responseText","fromResponse","checkGoogleKey","options","addressLookup","timezone","map","geolocator","_","config","google","key","GOOGLE_KEY_INVALID","getMapOpts","mapOptions","location","isObject","center","coords","element","formattedAddress","title","zoom","isNumber","accuracy","configCreateMap","elem","mapData","_geolocatorMapData","marker","infoWindow","maps","LatLng","latitude","longitude","mapTypeId","setMapTypeId","setCenter","setZoom","Map","Marker","event","clearInstanceListeners","setMap","position","InfoWindow","setContent","addListener","open","setFlagURL","address","cc","countryCode","length","country","flag","_enums2","URL","FLAG","toLowerCase","callbackMap","callback","createMap","error","_geocode","reverse","_geo2","geocode","fetchAddressAndTimezone","getTZ","cb","getTimeZone","loc","timestamp","time","clone","own","reverseGeocode","result","extend","locateAccurate","onPositionReceived","onPositionError","complete","POSITION_UNAVAILABLE","watcher","watch","clear","cycle","desiredAccuracy","timeout","Object","defineProperty","_typeof","Symbol","iterator","constructor","_createClass","defineProperties","target","props","i","descriptor","enumerable","configurable","writable","protoProps","staticProps","prototype","_utils","_fetch","_fetch2","_geo","_geo3","_geo5","_geo6","_enums","EARTH_RADIUS_KM","EARTH_RADIUS_MI","defaultConfig","language","https","version","MapTypeId","ROADMAP","undefined","e","document","getElementById","isJQueryObject","isGoogleLoaded","getDiv","isElement","isNode","INVALID_PARAMETERS","ensureGoogleLoaded","GOOGLE_API_FAILED","String","message","fallbackToIP","locateByIP","enableHighAccuracy","maximumAge","isGeolocationSupported","navigator","geolocation","getCurrentPosition","GEOLOCATION_NOT_SUPPORTED","homeMobileCountryCode","homeMobileNetworkCode","radioType","carrier","cellTowers","wifiAccessPoints","raw","considerIp","conf","url","setProtocol","GOOGLE_GEOLOCATION","xhrOpts","headers","Content-Type","data","JSON","stringify","post","isGeoError","lat","lng","source","geoIpSource","INVALID_GEO_IP_SOURCE","jsonpOpts","async","clean","callbackParam","rootName","globalVar","jsonp","window","INVALID_RESPONSE","schema","mapToSchema","provider","Number","isStringSet","freeze","onPositionChanged","pos","distance","calcDistance","from","to","formula","DistanceFormula","HAVERSINE","unitSystem","targetReached","radius","clearOnError","UnitSystem","METRIC","GOOGLE_TIMEZONE","timeZoneId","name","timeZoneName","abbr","dots","dstOffset","rawOffset","o","origins","origin","d","destinations","destination","toPointList","travelMode","TravelMode","DRIVING","avoidFerries","avoidHighways","avoidTolls","service","DistanceMatrixService","getDistanceMatrix","status","DistanceMatrixStatus","OK","formatDistanceResults","dLat","degToRad","dLng","a","Math","sin","cos","atan2","sqrt","latA","latB","lngA","lngB","x","y","IP","params","format","k","isFunction","GOOGLE_MAPS_API","isPositionError","km","mi","degrees","PI","radians","dec","isLng","arguments","sign","sn","we","nsew","absValue","abs","round","floor","get","LocationType","RadioType","setGeoIPSource","ip","city","state","stateCode","postalCode","region","_toString","toString","utils","noop","trim","type","Boolean","isDate","object","HTMLElement","nodeType","Node","jQuery","isError","Error","removeQuery","str","replace","removeProtocol","protocol","trimDots","encodeURI","encodeURIComponent","decodeURI","decodeURIComponent","randomString","len","random","slice","upper","s","match","join","toUpperCase","keys","encode","operator","separator","include","exclude","inc","exc","forIn","indexOf","v","push","notateGlobalObj","notation","levels","split","shift","forEach","note","_len","sources","Array","_key","concat","Date","cloned","hasOwnProperty","mapped","parse","seconds","ts","now","parseInt","_xhr","method","fetch","execCb","timeUp","clearTimeout","script","parentNode","removeChild","rootNameSet","cbFnName","defer","createElement","cbParamSet","query","qMark","fn","readyState","onreadystatechange","onload","onerror","errMsg","charset","crossorigin","src","getElementsByTagName","appendChild","setTimeout","XMLHttpRequest","hasCallback","withCredentials","mimeType","username","password","XHR_READY_STATE","DONE","crossDomain","ontimeout","setRequestHeader","overrideMimeType","send","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","geoHelper","toGoogleCoords","fromGoogleCoords","arr","getGeocodeComps","comp","route","locality","administrative_area","administrativeArea","postal_code","buildGeocodeParams","placeId","geoComps","b","bounds","southwestLat","southwestLng","northeastLat","northeastLng","formatGeocodeResults","results","comps","address_components","types","long_name","short_name","isUS","country_s","geometry","commonName","point_of_interest","premise","subpremise","colloquial_area","streetNumber","street_number","street","administrative_area_level_4","administrative_area_level_3","neighborhood","administrative_area_level_5","town","sublocality","administrative_area_level_2","administrative_area_level_1","administrative_area_level_1_s","formatted_address","location_type","place_id","opts","prop","coordsSet","GOOGLE_GEOCODE","gErr","originAddresses","dests","destinationAddresses","rows","oIndex","dest","dIndex","elements","duration","fare","enums","GOOGLE_DISTANCE_MATRIX","HYBRID","SATELLITE","TERRAIN","ROOFTOP","RANGE_INTERPOLATED","GEOMETRIC_CENTER","APPROXIMATE","WALKING","BICYCLING","TRANSIT","IMPERIAL","LTE","GSM","CDMA","WCDMA","PYTHAGOREAN","errorCodeFromStatus","GeoError","NOT_FOUND","errorCodeFromReason","reason","INVALID_REQUEST","DAILY_LIMIT_EXCEEDED","USER_RATE_LIMIT_EXCEEDED","PARSE_ERROR","code","UNKNOWN_ERROR","captureStackTrace","stack","PERMISSION_DENIED","TIMEOUT","msg","isValidErrorCode","errCode","error_message","errorMessage","errors","errorCode","setPrototypeOf","REQUEST_DENIED","OVER_QUERY_LIMIT","MAX_ELEMENTS_EXCEEDED","MAX_DIMENSIONS_EXCEEDED","MAX_WAYPOINTS_EXCEEDED","INTERNAL_ERROR","GeoWatcher","onChange","onError","_this","isCleared","_timer","watchPosition","clearWatch","delay","_this2","_clear"],"mappings":"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","file":"geolocator.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"geolocator\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geolocator\"] = factory();\n\telse\n\t\troot[\"geolocator\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"geolocator\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geolocator\"] = factory();\n\telse\n\t\troot[\"geolocator\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _geolocator = __webpack_require__(1);\n\t\n\tvar _geolocator2 = _interopRequireDefault(_geolocator);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// export default geolocator;\n\t// http://stackoverflow.com/a/33683495/112731\n\tmodule.exports = _geolocator2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tvar _fetch = __webpack_require__(3);\n\t\n\tvar _fetch2 = _interopRequireDefault(_fetch);\n\t\n\tvar _geo = __webpack_require__(4);\n\t\n\tvar _geo2 = _interopRequireDefault(_geo);\n\t\n\tvar _geo3 = __webpack_require__(6);\n\t\n\tvar _geo4 = _interopRequireDefault(_geo3);\n\t\n\tvar _geo5 = __webpack_require__(7);\n\t\n\tvar _geo6 = _interopRequireDefault(_geo5);\n\t\n\tvar _enums = __webpack_require__(5);\n\t\n\tvar _enums2 = _interopRequireDefault(_enums);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Radius of earth in kilometers.\n\t * @private\n\t * @type {Number}\n\t */\n\tvar EARTH_RADIUS_KM = 6371;\n\t\n\t/**\n\t * Radius of earth in miles.\n\t * @private\n\t * @type {Number}\n\t */\n\tvar EARTH_RADIUS_MI = 3959;\n\t\n\t/**\n\t * Storage for Geolocator default configuration.\n\t *\n\t * @readonly\n\t * @private\n\t */\n\tvar defaultConfig = {\n\t    language: 'en',\n\t    https: true,\n\t    google: {\n\t        version: '3', // latest 3.x\n\t        key: ''\n\t    }\n\t};\n\t\n\t/**\n\t * Geolocator library that provides methods for getting geo-location information,\n\t * geocoding, address look-ups, distance & durations, timezone information and more...\n\t * This library makes use of HTML5 position feautures, implements Google APIs\n\t * and other services.\n\t *\n\t * <b>Important Notes:</b>\n\t *\n\t * Although some calls might work without a key, it is generally required by\n\t * most {@link https://developers.google.com/maps/faq#using-google-maps-apis|Goolge APIs}\n\t * (such as Time Zone API). To get a free (or premium) key,\n\t * {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n\t * After getting a key, you can enable multiple APIs for it. Make sure you\n\t * {@link https://console.developers.google.com|enable}\n\t * all the APIs supported by Geolocator.\n\t *\n\t * Note that browser API keys cannot have referer restrictions when used\n\t * with some Google APIs.\n\t *\n\t * Make sure your doctype is HTML5 and you're calling Geolocation APIs from an\n\t * HTTPS page. Geolocation API is removed from unsecured origins in Chrome 50.\n\t * Other browsers are expected to follow.\n\t *\n\t * @license MIT\n\t * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n\t */\n\t\n\tvar geolocator = function () {\n\t    function geolocator() {\n\t        _classCallCheck(this, geolocator);\n\t    }\n\t\n\t    _createClass(geolocator, null, [{\n\t        key: 'config',\n\t\n\t\n\t        // ---------------------------\n\t        // STATIC METHODS\n\t        // ---------------------------\n\t\n\t        /**\n\t         * Sets or gets the geolocator configuration object.\n\t         * Make sure you configure Geolocator before calling other methods that\n\t         * require a Google API key.\n\t         *\n\t         * @param {Object} [options]\n\t         *        Configuration object. If omitted, this method returns the current\n\t         *        configuration.\n\t         *     @param {String} [options.language=\"en\"]\n\t         *            Language to be used for API requests that supports language\n\t         *            configurations. This is generally used for Google APIs.\n\t         *            See {@link https://developers.google.com/maps/faq#languagesupport|supported languages}.\n\t         *     @param {Boolean} [options.https=true]\n\t         *            As Google recommends; using HTTPS encryption makes your site\n\t         *            more secure, and more resistant to snooping or tampering.\n\t         *            If set to `true`, the API calls are made over HTTPS, at all\n\t         *            times. Setting to `false` will switch to HTTP (even if the\n\t         *            page is on HTTPS). And if set to `null`, current protocol will\n\t         *            be used. Note that some APIs might not work with HTTP such as\n\t         *            Google Maps TimeZone API.\n\t         *     @param {Object} [options.google]\n\t         *            Google specific options.\n\t         *         @param {String} [options.google.version=\"3\"]\n\t         *                Google Maps API version to be used (with\n\t         *                `geolocator.createMap()`) method. The default version\n\t         *                value is tested and works with Geolocator. You can set a\n\t         *                greater value or the latest version number and it should\n\t         *                work; but it's not guaranteed. Find out the\n\t         *                {@link https://developers.google.com/maps/documentation/javascript/versions|latest version here}.\n\t         *         @param {String} [options.google.key=\"\"]\n\t         *                API key to be used with Google API calls. Although some\n\t         *                calls might work without a key, it is generally required\n\t         *                by most Goolge APIs. To get a free (or premium) key,\n\t         *                {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n\t         *\n\t         * @returns {Object} - Returns the current or updated configuration object.\n\t         *\n\t         * @example\n\t         * geolocator.config({\n\t         *     language: \"en\",\n\t         *     google: {\n\t         *     \t   version: \"3\",\n\t         *         key: \"YOUR-GOOGLE-API-KEY\"\n\t         *     }\n\t         * });\n\t         */\n\t        value: function config(options) {\n\t            if (options) {\n\t                geolocator._.config = _utils2.default.extend(defaultConfig, options);\n\t            }\n\t            return geolocator._.config;\n\t        }\n\t\n\t        /**\n\t         * Creates a Google Map within the given element.\n\t         * @see {@link https://developers.google.com/maps/documentation/javascript/reference|Google Maps JavaScript API}\n\t         * @see {@link https://developers.google.com/maps/documentation/javascript/usage|Usage Limits}\n\t         *\n\t         * @param {Object|String|HTMLElement|Map} options\n\t         *        Either map options object with the following properties or; the ID\n\t         *        of a DOM element, or element itself which the map will be\n\t         *        created within; or a previously created `google.maps.Map` instance.\n\t         *        If a map instance is set, this only will apply the options without\n\t         *        re-creating it.\n\t         *     @param {String|HTMLElement|Map} options.element\n\t         *            Either the ID of a DOM element or the element itself;\n\t         *            which the map will be created within; or a previously created\n\t         *            `google.maps.Map` instance. If a map instance is set, this\n\t         *            only will apply the options without re-creating it.\n\t         *     @param {Object} options.center\n\t         *            Center coordinates for the map to be created.\n\t         *         @param {Number} options.center.latitude\n\t         *                Latitude of the center point coordinates.\n\t         *         @param {Number} options.center.longitude\n\t         *                Longitude of the center point coordinates.\n\t         *     @param {String} [options.mapTypeId=\"roadmap\"]\n\t         *            Type of the map to be created.\n\t         *            See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n\t         *            for possible values.\n\t         *     @param {String} [options.title]\n\t         *            Title text to be displayed within an `InfoWindow`, when the\n\t         *            marker is clicked. This only take effect if `marker` is\n\t         *            enabled.\n\t         *     @param {Boolean} [options.marker=true]\n\t         *            Whether to place a marker at the given coordinates.\n\t         *            If `title` is set, an `InfoWindow` will be opened when the\n\t         *            marker is clicked.\n\t         *     @param {Number} [options.zoom=9]\n\t         *            Zoom level to be set for the map.\n\t         *\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the map is created.\n\t         *        This takes 2 arguments: `function (err, map) { ... }`.\n\t         *        See {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var options = {\n\t         *     element: \"my-map\",\n\t         * \t   center: {\n\t         * \t       latitude: 48.8534100,\n\t         *         longitude: 2.3488000\n\t         * \t   },\n\t         * \t   marker: true,\n\t         * \t   title: \"Paris, France\",\n\t         * \t   zoom: 12\n\t         * };\n\t         * geolocator.createMap(options, function (err, map) {\n\t         * \t   if (map && map.infoWindow) {\n\t         * \t\t   map.infoWindow.open(map.instance, map.marker);\n\t         * \t   }\n\t         * });\n\t         */\n\t\n\t    }, {\n\t        key: 'createMap',\n\t        value: function createMap(options, callback) {\n\t            // if options is not a plain object, consider element ID, `HTMLElement`,\n\t            // `jQuery` instance or `google.maps.Map` instance.\n\t            if (!_utils2.default.isPlainObject(options)) {\n\t                options = { element: options };\n\t            }\n\t\n\t            options = _utils2.default.extend({\n\t                element: null,\n\t                mapTypeId: _enums2.default.MapTypeId.ROADMAP,\n\t                title: undefined,\n\t                marker: true,\n\t                zoom: 9\n\t            }, options);\n\t\n\t            var e = options.element,\n\t                elem = void 0;\n\t            if (_utils2.default.isString(e)) {\n\t                elem = document.getElementById(e);\n\t            } else if (_utils2.default.isJQueryObject(e)) {\n\t                elem = e[0];\n\t            } else if (geolocator.isGoogleLoaded() && e instanceof google.maps.Map) {\n\t                elem = e.getDiv();\n\t            }\n\t\n\t            if (!_utils2.default.isElement(elem) && !_utils2.default.isNode(elem)) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'A valid DOM element or element ID is required to create a map.');\n\t            }\n\t\n\t            if (!_utils2.default.isPlainObject(options.center) || !_utils2.default.isNumber(options.center.latitude) || !_utils2.default.isNumber(options.center.longitude)) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'Center coordinates are required to create a map.');\n\t            }\n\t\n\t            options.element = elem;\n\t\n\t            var key = geolocator._.config.google.key;\n\t            geolocator.ensureGoogleLoaded(key, function (err) {\n\t                if (err) {\n\t                    throw new _geo4.default(_geo4.default.Code.GOOGLE_API_FAILED, String(err.message || err));\n\t                }\n\t\n\t                var mapData = configCreateMap(options);\n\t                callback(null, mapData);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Locates the user's location via HTML5 geolocation. This may\n\t         * require/prompt for user's permission. If the permission is granted we'll\n\t         * get the most accurate location information. Otherwise, we'll fallback to\n\t         * locating via user's IP (if enabled).\n\t         *\n\t         * For better accuracy, Geolocator implements a different approach than the\n\t         * `getCurrentPosition` API; which generally triggers before the device's\n\t         * GPS hardware can provide anything accurate. Thanks to\n\t         * {@link https://github.com/gwilson/getAccurateCurrentPosition#background|Greg Wilson}\n\t         * for the idea.\n\t         *\n\t         * Also note that HTML5 Geolocation feature no more allows insecure origins.\n\t         * See {@link https://goo.gl/rStTGz|this} for more details.\n\t         * This means if you don't call this method from an HTTPS page, it will\n\t         * fail. And if `options.fallbackToIP` is enabled, this will locate by IP.\n\t         *\n\t         * @param {Object} [options]\n\t         *        HTML5 geo-location settings with some additional options.\n\t         *     @param {Boolean} [options.enableHighAccuracy=true]\n\t         *            Specifies whether the device should provide the most accurate\n\t         *            position it can. Note that setting this to `true` might\n\t         *            consume more CPU and/or battery power; and result in slower\n\t         *            response times.\n\t         *     @param {Number} [options.timeout=6000]\n\t         *            HTML5 position timeout setting in milliseconds. Setting this\n\t         *            to `Infinity` means that Geolocator won't return until the\n\t         *            position is available.\n\t         *     @param {Number} [options.maximumAge=0]\n\t         *            HTML5 position maximum age. Indicates the maximum age in\n\t         *            milliseconds of a possible cached position that is acceptable\n\t         *            to return. `0` means, the device cannot use a cached position\n\t         *            and must attempt to retrieve the real current position. If set\n\t         *            to `Infinity` the device must return a cached position\n\t         *            regardless of its age. Note that if `enableHighAccuracy` is\n\t         *            set to `true`, `maximumAge` will be forced to `0`.\n\t         *     @param {Number} [options.desiredAccuracy=30]\n\t         *            Minimum accuracy desired, in meters. Position will not be\n\t         *            returned until this is met, before the timeout. This only\n\t         *            takes effect if `enableHighAccuracy` is set to `true`.\n\t         *     @param {Boolean} [options.fallbackToIP=false]\n\t         *            Specifies whether to fallback to IP geolocation if the HTML5\n\t         *            geolocation fails (e.g. user rejection).\n\t         *     @param {Boolean} [options.addressLookup=false]\n\t         *            Specifies whether to run a reverse-geocode operation for the\n\t         *            fetched coordinates to retrieve detailed address information.\n\t         *            Note that this means an additional request which requires a\n\t         *            Google API key to be set in the Geolocator configuration.\n\t         *            See {@link #geolocator.config|`geolocator.config()`}.\n\t         *     @param {Boolean} [options.timezone=false]\n\t         *            Specifies whether to also fetch the time zone information for\n\t         *            the receieved coordinates. Note that this means an additional\n\t         *            request which requires a Google API key to be set in the\n\t         *            Geolocator configuration.\n\t         *            See {@link #geolocator.config|`geolocator.config()`}.\n\t         *     @param {String|Object} [options.map]\n\t         *            In order to create a map from the fetched location coordinates;\n\t         *            either set this to map options object or; the ID of a DOM\n\t         *            element or DOM element itself which the map will be created\n\t         *            within.\n\t         *\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes.\n\t         *        This takes 2 arguments: `function (err, location) { ... }`.\n\t         *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var options = {\n\t         *     enableHighAccuracy: true,\n\t         *     timeout: 6000,\n\t         *     maximumAge: 0,\n\t         *     desiredAccuracy: 30,\n\t         *     fallbackToIP: true,\n\t         *     addressLookup: true,\n\t         *     timezone: true,\n\t         *     map: \"my-map\"\n\t         * };\n\t         * geolocator.locate(options, function (err, location) {\n\t         *     console.log(err || location);\n\t         * });\n\t         *\n\t         * @example\n\t         * // location result:\n\t         * {\n\t         *     coords: {\n\t         *         latitude: 37.4224764,\n\t         *         longitude: -122.0842499,\n\t         *         accuracy: 30,\n\t         *         altitude: null,\n\t         *         altitudeAccuracy: null,\n\t         *         heading: null,\n\t         *         speed: null\n\t         *     },\n\t         *     address: {\n\t         *         commonName: \"\",\n\t         *         street: \"Amphitheatre Pkwy\",\n\t         *         route: \"Amphitheatre Pkwy\",\n\t         *         streetNumber: \"1600\",\n\t         *         neighborhood: \"\",\n\t         *         town: \"\",\n\t         *         city: \"Mountain View\",\n\t         *         region: \"Santa Clara County\",\n\t         *         state: \"California\",\n\t         *         stateCode: \"CA\",\n\t         *         postalCode: \"94043\",\n\t         *         country: \"United States\",\n\t         *         countryCode: \"US\"\n\t         *     },\n\t         *     formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n\t         *     type: \"ROOFTOP\",\n\t         *     placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n\t         *     timezone: {\n\t         *         id: \"America/Los_Angeles\",\n\t         *         name: \"Pacific Standard Time\",\n\t         *         abbr: \"PST\",\n\t         *         dstOffset: 0,\n\t         *         rawOffset: -28800\n\t         *     },\n\t         *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n\t         *     map: {\n\t         *     \t   element: HTMLElement,\n\t         *     \t   instance: Object, // google.maps.Map\n\t         *     \t   marker: Object, // google.maps.Marker\n\t         *     \t   infoWindow: Object, // google.maps.InfoWindow\n\t         *     \t   options: Object // map options\n\t         *     },\n\t         *     timestamp: 1456795956380\n\t         * }\n\t         */\n\t\n\t    }, {\n\t        key: 'locate',\n\t        value: function locate(options, callback) {\n\t            options = _utils2.default.extend({\n\t                enableHighAccuracy: true,\n\t                timeout: 6000,\n\t                maximumAge: 0,\n\t                desiredAccuracy: 30,\n\t                fallbackToIP: false,\n\t                addressLookup: false,\n\t                timezone: false,\n\t                map: undefined\n\t            }, options);\n\t\n\t            // force disable cache if high-accuracy is enabled\n\t            if (options.enableHighAccuracy) options.maximumAge = 0;\n\t            // check options and Google key\n\t            checkGoogleKey(options);\n\t\n\t            var cb = callbackMap(options, callback);\n\t\n\t            function fallbackToIP(error) {\n\t                if (options.fallbackToIP) {\n\t                    return geolocator.locateByIP(options, function (err, location) {\n\t                        if (err) return cb(err, null);\n\t                        return cb(null, location);\n\t                    });\n\t                }\n\t                cb(error, null);\n\t            }\n\t            function onPositionReceived(location) {\n\t                fetchAddressAndTimezone(location, options, cb);\n\t            }\n\t            function onPositionError(err) {\n\t                err = _geo4.default.create(err);\n\t                fallbackToIP(err);\n\t            }\n\t\n\t            if (geolocator.isGeolocationSupported()) {\n\t                if (options.enableHighAccuracy) {\n\t                    locateAccurate(options, onPositionReceived, onPositionError);\n\t                } else {\n\t                    navigator.geolocation.getCurrentPosition(onPositionReceived, onPositionError, options);\n\t                }\n\t            } else {\n\t                var err = new _geo4.default(_geo4.default.Code.GEOLOCATION_NOT_SUPPORTED);\n\t                fallbackToIP(err);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Returns a location and accuracy radius based on information about cell\n\t         * towers and WiFi nodes that the mobile client can detect; via the Google\n\t         * Maps Geolocation API.\n\t         * @see {@link https://developers.google.com/maps/documentation/geolocation/intro|Google Maps Geolocation API}\n\t         * @see {@link https://developers.google.com/maps/documentation/geolocation/usage-limits|Usage Limits}\n\t         *\n\t         * @param {Object} [options]\n\t         *        Geolocation options.\n\t         *     @param {Number} [options.homeMobileCountryCode]\n\t         *            The mobile country code (MCC) for the device's home network.\n\t         *     @param {Number} [options.homeMobileNetworkCode]\n\t         *            The mobile network code (MNC) for the device's home network.\n\t         *     @param {String} [options.radioType]\n\t         *            The mobile radio type.\n\t         *            See {@link #geolocator.RadioType|`geolocator.RadioType` enumeration}\n\t         *            for possible values. While this field is optional, it should\n\t         *            be included if a value is available, for more accurate results.\n\t         *     @param {string} [options.carrier]\n\t         *            The carrier name. e.g. \"Vodafone\"\n\t         *     @param {Boolean} [options.fallbackToIP=false]\n\t         *            Specifies whether to fallback to IP geolocation if wifi and\n\t         *            cell tower signals are not available. Note that the IP address\n\t         *            in the request header may not be the IP of the device. Set\n\t         *            `fallbackToIP` to `false` to disable fall back.\n\t         *     @param {Array} [options.cellTowers]\n\t         *            An array of cell tower objects.\n\t         *            See {@link https://developers.google.com/maps/documentation/geolocation/intro#cell_tower_object|Cell tower objects} for details.\n\t         *     @param {Array} [options.wifiAccessPoints]\n\t         *            An array of WiFi access point objects.\n\t         *            See {@link https://developers.google.com/maps/documentation/geolocation/intro#wifi_access_point_object|WiFi access point objects} for details.\n\t         *     @param {Boolean} [options.addressLookup=false]\n\t         *            Specifies whether to run a reverse-geocode operation for the\n\t         *            fetched coordinates to retrieve detailed address information.\n\t         *            Note that this means an additional request which requires a\n\t         *            Google API key to be set in the Geolocator configuration.\n\t         *            See {@link #geolocator.config|`geolocator.config()`}.\n\t         *     @param {Boolean} [options.timezone=false]\n\t         *            Specifies whether to also fetch the time zone information for\n\t         *            the receieved coordinates. Note that this means an additional\n\t         *            request which requires a Google API key to be set in the\n\t         *            Geolocator configuration.\n\t         *            See {@link #geolocator.config|`geolocator.config()`}.\n\t         *     @param {String|Object} [options.map]\n\t         *            In order to create a map from the fetched location coordinates;\n\t         *            either set this to map options object or; the ID of a DOM\n\t         *            element or DOM element itself which the map will be created\n\t         *            within.\n\t         *     @param {Boolean} [options.raw=false]\n\t         *     \t      Whether to return the raw Google API result.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes.\n\t         *        This takes 2 arguments: `function (err, location) { ... }`.\n\t         *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var options = {\n\t         *     homeMobileCountryCode: 310,\n\t         *     homeMobileNetworkCode: 410,\n\t         *     carrier: 'Vodafone',\n\t         *     radioType: geolocator.RadioType.GSM,\n\t         *     fallbackToIP: true,\n\t         *     addressLookup: false,\n\t         *     timezone: false,\n\t         *     map: \"my-map\"\n\t         * };\n\t         * geolocator.locateByMobile(options, function (err, location) {\n\t         *     console.log(err || location);\n\t         * });\n\t         */\n\t\n\t    }, {\n\t        key: 'locateByMobile',\n\t        value: function locateByMobile(options, callback) {\n\t            if (!_utils2.default.isPlainObject(options)) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS);\n\t            }\n\t\n\t            var cb = callbackMap(options, callback);\n\t\n\t            options = _utils2.default.extend({\n\t                homeMobileCountryCode: undefined,\n\t                homeMobileNetworkCode: undefined,\n\t                radioType: undefined,\n\t                carrier: undefined,\n\t                fallbackToIP: false,\n\t                cellTowers: undefined,\n\t                wifiAccessPoints: undefined,\n\t                addressLookup: false,\n\t                timezone: false,\n\t                map: undefined,\n\t                raw: false\n\t            }, options);\n\t\n\t            options.considerIp = options.fallbackToIP;\n\t            // check Google key\n\t            checkGoogleKey();\n\t\n\t            var conf = geolocator._.config,\n\t                key = conf.google.key || '',\n\t                url = _utils2.default.setProtocol(_enums2.default.URL.GOOGLE_GEOLOCATION, conf.https),\n\t                xhrOpts = {\n\t                url: url + '?key=' + key,\n\t                headers: {\n\t                    'Content-Type': 'application/json'\n\t                },\n\t                data: JSON.stringify(options)\n\t            };\n\t            // console.log(xhrOpts.data);\n\t\n\t            _fetch2.default.post(xhrOpts, function (err, xhr) {\n\t                var response = getXHRResponse(err, xhr);\n\t                if (_geo4.default.isGeoError(response)) return cb(response, null);\n\t\n\t                response = options.raw ? response : {\n\t                    coords: {\n\t                        latitude: response.location.lat,\n\t                        longitude: response.location.lng,\n\t                        accuracy: response.accuracy\n\t                    },\n\t                    timestamp: _utils2.default.time()\n\t                };\n\t\n\t                fetchAddressAndTimezone(response, options, cb);\n\t\n\t                // e.g. raw response\n\t                // {\n\t                //     \"location\": {\n\t                //         \"lat\": 51.0,\n\t                //         \"lng\": -0.1\n\t                //     },\n\t                //     \"accuracy\": 1200.4\n\t                // }\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Locates the user's location by the client's IP.\n\t         *\n\t         * This method uses Wikimedia's Geo-IP lookup service, by default.\n\t         * In order to change the source provider, you can use\n\t         * {@link #geolocator.setGeoIPSource|`geolocator.setGeoIPSource()` method}.\n\t         *\n\t         * @param {Object} [options]\n\t         *        Locate options.\n\t         *     @param {Boolean} [options.addressLookup=false]\n\t         *            Specifies whether to run a reverse-geocode operation for the\n\t         *            fetched coordinates to retrieve detailed address information.\n\t         *            Since no precise address can be fetched from an IP addres; you\n\t         *            should only enable this if the Geo-IP Source returns no useful\n\t         *            address information other than coordinates. Also, note that\n\t         *            this means an additional request which requires a Google API\n\t         *            key to be set in the Geolocator configuration.\n\t         *            See {@link #geolocator.config|`geolocator.config()`}.\n\t         *     @param {Boolean} [options.timezone=false]\n\t         *            Specifies whether to also fetch the time zone information for\n\t         *            the receieved coordinates. Note that this means an additional\n\t         *            request which requires a Google API key to be set in the\n\t         *            Geolocator configuration.\n\t         *            See {@link #geolocator.config|`geolocator.config()`}.\n\t         *     @param {String|Object} [options.map]\n\t         *            In order to create a map from the fetched location coordinates;\n\t         *            either set this to map options object or; the ID of a DOM\n\t         *            element or DOM element itself which the map will be created\n\t         *            within.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes.\n\t         *        This takes 2 arguments: `function (err, location) { ... }`.\n\t         *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var options = {\n\t         * \t   addressLookup: true,\n\t         * \t   timezone: true,\n\t         * \t   map: \"my-map\"\n\t         * };\n\t         * geolocator.locateByIp(options, function (err, location) {\n\t         * \t   console.log(err || location);\n\t         * });\n\t         *\n\t         * @example\n\t         * // location result:\n\t         * {\n\t         *     coords: {\n\t         *         latitude: 37.4224764,\n\t         *         longitude: -122.0842499,\n\t         *     },\n\t         *     address: {\n\t         *         city: \"Istanbul\",\n\t         *         region: \"34\",\n\t         *         state: \"34\",\n\t         *         country: \"TR\",\n\t         *         countryCode: \"TR\"\n\t         *     },\n\t         *     formattedAddress: \"Demirtaş, Tesviyeci Sk. No:7, 34134 Fatih/İstanbul, Turkey\",\n\t         *     type: \"ROOFTOP\",\n\t         *     placeId: \"ChIJ-ZRLfO25yhQRBi5YJxX80Q0\",\n\t         *     timezone: {\n\t         *         id: \"Europe/Istanbul\",\n\t         *         name: \"Eastern European Summer Time\",\n\t         *         abbr: \"EEST\",\n\t         *         dstOffset: 3600,\n\t         *         rawOffset: 7200\n\t         *     },\n\t         *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/tr.svg\",\n\t         *     map: {\n\t         *     \t   element: HTMLElement,\n\t         *     \t   instance: Object, // google.maps.Map\n\t         *     \t   marker: Object, // google.maps.Marker\n\t         *     \t   infoWindow: Object, // google.maps.InfoWindow\n\t         *     \t   options: Object // map options\n\t         *     },\n\t         *     provider: \"wikimedia\",\n\t         *     timestamp: 1466216325223\n\t         * }\n\t         */\n\t\n\t    }, {\n\t        key: 'locateByIP',\n\t        value: function locateByIP(options, callback) {\n\t            // passed source can be a string or object\n\t            var source = geolocator._.geoIpSource;\n\t\n\t            if (!_utils2.default.isPlainObject(source)) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_GEO_IP_SOURCE, 'Please set a valid Geo-IP Source via geolocator.setGeoIPSource(options).');\n\t            }\n\t\n\t            // check options and Google key\n\t            checkGoogleKey(options || {});\n\t\n\t            var jsonpOpts = {\n\t                url: source.url,\n\t                async: true,\n\t                clean: true\n\t                // params: {}\n\t            };\n\t            if (source.callbackParam) {\n\t                jsonpOpts.callbackParam = source.callbackParam;\n\t                jsonpOpts.rootName = 'geolocator._.cb';\n\t            } else if (!source.globalVar) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_GEO_IP_SOURCE, 'Either callbackParam or globalVar should be set for Geo-IP source.');\n\t            }\n\t            return _fetch2.default.jsonp(jsonpOpts, function (err, response) {\n\t                if (err) {\n\t                    return callback(_geo4.default.create(err), null);\n\t                }\n\t                if (source.globalVar) {\n\t                    if (window[source.globalVar]) {\n\t                        response = _utils2.default.clone(window[source.globalVar]);\n\t                        delete window[source.globalVar];\n\t                    } else {\n\t                        response = null;\n\t                    }\n\t                }\n\t                if (!response) {\n\t                    err = new _geo4.default(_geo4.default.Code.INVALID_RESPONSE);\n\t                    return callback(err, null);\n\t                }\n\t                if (_utils2.default.isPlainObject(source.schema)) {\n\t                    response = _utils2.default.mapToSchema(response, source.schema);\n\t                }\n\t                response.provider = source.provider || 'unknown';\n\t                setFlagURL(response);\n\t                if (response.coords) {\n\t                    response.coords.latitude = Number(response.coords.latitude);\n\t                    response.coords.longitude = Number(response.coords.longitude);\n\t                }\n\t                var cb = callbackMap(options, callback);\n\t                fetchAddressAndTimezone(response, options, cb);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Sets the Geo-IP source to be used for fetching location information\n\t         * by user's IP; which is internally used by\n\t         * {@link #geolocator.locateByIP|`geolocator.locateByIP()` method}.\n\t         *\n\t         * By default, Geolocator uses Wikimedia as the Geo-IP source provider.\n\t         * You can use this method to change this; or you can choose from\n\t         * ready-to-use\n\t         * {@link https://github.com/onury/geolocator/tree/master/src/geo-ip-sources|Geo-IP sources}.\n\t         *\n\t         * @param {Object} options\n\t         *        Geo-IP Source options.\n\t         *     @param {String} [options.provider]\n\t         *            Source or service provider's name.\n\t         *     @param {String} options.url\n\t         *            Source URL without the callback query parameter. The callback\n\t         *            name (if supported) should be set via `options.callbackParam`.\n\t         *            Also, make sure the service supports the protocol you use in\n\t         *            the enums.URL. If it supports both HTTP and HTTPS, you can omit the\n\t         *            protocol. In this case, it will be determined via Geolocator\n\t         *            configuration.\n\t         *            See {@link #geolocator.config|`geolocator.config()`}.\n\t         *            NOTE: Do not forget to include your API key in the query\n\t         *            parameters of the URL, if you have one.\n\t         *     @param {String} [options.callbackParam]\n\t         *            If JSON callback is supported, pass the name of the callback\n\t         *            parameter, defined by the provider.\n\t         *     @param {Object} [options.globalVar]\n\t         *            Set this instead of `options.callbackParam` if the service\n\t         *            does not support JSON callbacks, but weirdly set a global\n\t         *            variable in the document. For example, if the response is\n\t         *            `Geo = { lat, lng }`, you should set this to `\"Geo\"`.\n\t         *     @param {Object} [options.schema]\n\t         *            Schema object to be used to re-structure the response returned\n\t         *            from the service. Set the response object's keys as values of\n\t         *            a custom object to map the format to the `location` object.\n\t         *            For example; if the service returns a response like\n\t         *            `{ lat: 40.112233, lng: 10.112233, otherProp: 'hello' }`.\n\t         *            Then you should set the following schema:\n\t         *            `{ coords: { latitude: 'lat', longitude: 'lng' } }`.\n\t         *\n\t         * @return {geolocator}\n\t         */\n\t\n\t    }, {\n\t        key: 'setGeoIPSource',\n\t        value: function setGeoIPSource(options) {\n\t            if (!_utils2.default.isPlainObject(options)) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'Geo-IP source options is invalid.');\n\t            }\n\t            if (!_utils2.default.isStringSet(options.url)) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'Geo-IP source should have a valid URI.');\n\t            }\n\t            // if (!utils.isStringSet(options.callbackParam) && !utils.isStringSet(options.globalVar)) {\n\t            //     throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'No \\'callbackParam\\' or \\'globalVar\\' is provided for the Geo-IP Source options.');\n\t            // }\n\t            geolocator._.geoIpSource = Object.freeze(options);\n\t        }\n\t\n\t        /**\n\t         * Registers a handler for watching the user's location via HTML5\n\t         * geolocation; that is triggered each time the position of the device\n\t         * changes. This may require/prompt for user's permission.\n\t         *\n\t         * @param {Object} [options]\n\t         *        HTML5 geo-location settings.\n\t         *     @param {Boolean} [options.enableHighAccuracy=true]\n\t         *            Specifies whether the device should provide the most accurate\n\t         *            position it can. Note that setting this to `true` might consume\n\t         *            more CPU and/or battery power; and result in slower response\n\t         *            times.\n\t         *     @param {Number} [options.timeout=6000]\n\t         *            HTML5 position timeout setting in milliseconds. Setting this\n\t         *            to `Infinity` means that Geolocator won't return until the\n\t         *            position is available.\n\t         *     @param {Number} [options.maximumAge=0]\n\t         *            HTML5 position maximum age. Indicates the maximum age in\n\t         *            milliseconds of a possible cached position that is acceptable\n\t         *            to return. `0` means, the device cannot use a cached position\n\t         *            and must attempt to retrieve the real current position. If set\n\t         *            to `Infinity` the device must return a cached position\n\t         *            regardless of its age.\n\t         *     @param {Boolean} [options.clearOnError=false]\n\t         *            Specifies whether to clear the watcher on first error so that\n\t         *            it does not execute any more callbacks.\n\t         *     @param {Object} [options.target]\n\t         *            Object that defines the target location and settings; that\n\t         *            when the location is reached, the watcher will auto-clear\n\t         *            itself and invoke the callback.\n\t         *     @param {Number} options.target.latitude\n\t         *            The `latitude` of the target location.\n\t         *     @param {Number} options.target.longitude\n\t         *            The `longitude` of the target location.\n\t         *     @param {Number} [options.target.radius=0.5]\n\t         *            The radius, in other words; the minimum distance (in\n\t         *            kilometers or miles) to the target point that should be\n\t         *            reached.\n\t         *     @param {Number} [options.target.unitSystem=0]\n\t         *            Unit system to be used for target radius.\n\t         *            See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n\t         *            for possible values.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes.\n\t         *        This takes 2 arguments: `function (err, location) { ... }`.\n\t         *        If `options.target` is set, `location` will also\n\t         *        include a `targetReached:Boolean` property.\n\t         *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n\t         *\n\t         * @returns {GeoWatcher} - A watcher object that provides a\n\t         * `.clear(delay:Number, callback:Function)` method to clear the watcher\n\t         * when needed. Optional `delay` argument can be set (in milliseconds) to\n\t         * clear in a later time. Omitting this argument will clear the watcher\n\t         * immediately. You should always call this method, except if you've set up\n\t         * a target; which will auto-clear the watcher when reached.\n\t         *\n\t         * @example\n\t         * // Watch my position for 5 minutes.\n\t         * var options = { enableHighAccuracy: true, timeout: 6000, maximumAge: 0 };\n\t         * var watcher = geolocator.watch(options, function (err, location) {\n\t         *     console.log(err || location);\n\t         * });\n\t         * console.log(watcher.id); // ID of the watcher\n\t         * watcher.clear(300000); // clear after 5 minutes.\n\t         *\n\t         * @example\n\t         * // Watch my position until I'm 350 meters near Disneyland Park.\n\t         * options.target = {\n\t         *     latitude: 33.8120918,\n\t         *     longitude: -117.9233569,\n\t         *     radius: 0.35,\n\t         *     unitSystem: geolocator.UnitSystem.METRIC\n\t         * };\n\t         * watcher = geolocator.watch(options, function (err, location) {\n\t         *     if (err) {\n\t         *         console.log(err);\n\t         *         return;\n\t         *     }\n\t         *     if (location.targetReached) {\n\t         *         console.log(watcher.isCleared); // true\n\t         *         console.log(watcher.cycle); // 15 — target reached after 15 cycles\n\t         *     } else {\n\t         *         console.log(watcher.isCleared); // false — watcher is active.\n\t         *     }\n\t         * });\n\t         */\n\t\n\t    }, {\n\t        key: 'watch',\n\t        value: function watch(options, callback) {\n\t            if (!geolocator.isGeolocationSupported()) {\n\t                callback(new _geo4.default(_geo4.default.Code.GEOLOCATION_NOT_SUPPORTED), null);\n\t                return {};\n\t            }\n\t\n\t            var watcher = void 0,\n\t                target = void 0;\n\t\n\t            options = _utils2.default.extend({\n\t                enableHighAccuracy: true,\n\t                timeout: 6000,\n\t                maximumAge: 0,\n\t                clearOnError: false\n\t            }, options);\n\t\n\t            if (_utils2.default.isPlainObject(options.target)) {\n\t                target = _utils2.default.extend({\n\t                    radius: 0.5,\n\t                    unitSystem: geolocator.UnitSystem.METRIC\n\t                }, options.target);\n\t            }\n\t\n\t            function onPositionChanged(location) {\n\t                var pos = _utils2.default.clone(location, { own: false });\n\t                if (target) {\n\t                    var distance = geolocator.calcDistance({\n\t                        from: location.coords,\n\t                        to: target,\n\t                        formula: geolocator.DistanceFormula.HAVERSINE,\n\t                        unitSystem: target.unitSystem\n\t                    });\n\t                    pos.targetReached = distance <= target.radius;\n\t                    if (watcher && pos.targetReached) {\n\t                        watcher.clear(function () {\n\t                            return callback(null, pos);\n\t                        });\n\t                    }\n\t                }\n\t                return callback(null, pos);\n\t            }\n\t            function onPositionError(err) {\n\t                callback(_geo4.default.create(err), null);\n\t            }\n\t            return new _geo6.default(onPositionChanged, onPositionError, options);\n\t        }\n\t\n\t        /**\n\t         * Converts a given address (or address components) into geographic\n\t         * coordinates (i.e. latitude, longitude); and gets detailed address\n\t         * information.\n\t         * @see {@link https://developers.google.com/maps/documentation/geocoding/intro|Google Maps Geocoding API}\n\t         * @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n\t         *\n\t         * @param {String|Object} options\n\t         *        Either the address to geocode or geocoding options with the\n\t         *        following properties.\n\t         *     @param {String} options.address\n\t         *            The street address to geocode, in the format used by the\n\t         *            national postal service of the country concerned. Additional\n\t         *            address elements such as business names and unit, suite or\n\t         *            floor numbers should be avoided. Note that any address\n\t         *            component (route, locality, administrativeArea, postalCode and\n\t         *            country) should be specified either in address or the\n\t         *            corresponding property - not both. Doing so may result in\n\t         *            `ZERO_RESULTS`.\n\t         *     @param {String} [options.route]\n\t         *     \t      Long or short name of a route.\n\t         *     @param {String} [options.locality]\n\t         *     \t      Locality and sublocality of the location.\n\t         *     @param {String} [options.administrativeArea]\n\t         *     \t      Administrative area of the location.\n\t         *     @param {String} [options.postalCode]\n\t         *     \t      Postal code of the location.\n\t         *     @param {String} [options.country]\n\t         *     \t      A country name or a two letter ISO 3166-1 country code.\n\t         *     @param {String} [options.region]\n\t         *     \t      The region code, specified as a ccTLD (\"top-level domain\")\n\t         *     \t      two-character value. e.g.: `\"fr\"` for France.\n\t         *     @param {Array|Object} [options.bounds]\n\t         *     \t      The bounding box of the viewport within which to bias geocode\n\t         *     \t      results more prominently. e.g.:\n\t         *     \t      `[ southwestLat:Number, southwestLng:Number, northeastLat:Number, northeastLng:Number ]`\n\t         *     @param {String|Object} [options.map]\n\t         *            In order to create a map from the fetched location coordinates;\n\t         *            either set this to map options object or; the ID of a DOM\n\t         *            element or DOM element itself which the map will be created\n\t         *            within.\n\t         *     @param {Boolean} [options.raw=false]\n\t         *     \t      Whether to return the raw Google API result.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes.\n\t         *        This takes 2 arguments: `function (err, location) { ... }`.\n\t         *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var address = '1600 Amphitheatre Parkway, CA';\n\t         * geolocator.geocode(address, function (err, location) {\n\t         *     console.log(err || location);\n\t         * });\n\t         *\n\t         * @example\n\t         * // location result:\n\t         * {\n\t         *     coords: {\n\t         *         latitude: 37.4224764,\n\t         *         longitude: -122.0842499\n\t         *     },\n\t         *     address: {\n\t         *         commonName: \"\",\n\t         *         street: \"Amphitheatre Pkwy\",\n\t         *         route: \"Amphitheatre Pkwy\",\n\t         *         streetNumber: \"1600\",\n\t         *         neighborhood: \"\",\n\t         *         town: \"\",\n\t         *         city: \"Mountain View\",\n\t         *         region: \"Santa Clara County\",\n\t         *         state: \"California\",\n\t         *         stateCode: \"CA\",\n\t         *         postalCode: \"94043\",\n\t         *         country: \"United States\",\n\t         *         countryCode: \"US\"\n\t         *     },\n\t         *     formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n\t         *     type: \"ROOFTOP\",\n\t         *     placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n\t         *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n\t         *     map: {\n\t         *     \t   element: HTMLElement,\n\t         *     \t   instance: Object, // google.maps.Map\n\t         *     \t   marker: Object, // google.maps.Marker\n\t         *     \t   infoWindow: Object, // google.maps.InfoWindow\n\t         *     \t   options: Object // map options\n\t         *     },\n\t         *     timestamp: 1456795956380\n\t         * }\n\t         */\n\t\n\t    }, {\n\t        key: 'geocode',\n\t        value: function geocode(options, callback) {\n\t            _geocode(false, options, callback);\n\t        }\n\t\n\t        /**\n\t         * Converts the given geographic coordinates into a human-readable address\n\t         * information.\n\t         * @see {@link https://developers.google.com/maps/documentation/geocoding/intro#ReverseGeocoding|Google Maps (Reverse) Geocoding API}\n\t         * @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n\t         * @alias geolocator.addressLookup\n\t         *\n\t         * @param {Object|String} options\n\t         *        Either the `placeId` of the location or Reverse Geocoding options\n\t         *        with the following properties.\n\t         *     @param {Number} options.latitude\n\t         *     Latitude of the target location.\n\t         *     @param {Number} options.longitude\n\t         *     Longitude of the target location.\n\t         *     @param {String} [options.placeId]\n\t         *            Required if `latitude` and `longitude` are omitted. The place\n\t         *            ID of the place for which you wish to obtain the\n\t         *            human-readable address. The place ID is a unique identifier\n\t         *            that can be used with other Google APIs. Note that if\n\t         *            `placeId` is set, `latitude` and `longitude` are ignored.\n\t         *     @param {String|Object} [options.map]\n\t         *            In order to create a map from the given location coordinates;\n\t         *            either set this to map options object or; the ID of a DOM\n\t         *            element or DOM element itself which the map will be created\n\t         *            within.\n\t         *     @param {Boolean} [options.raw=false]\n\t         *            Whether to return the raw Google API result.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes.\n\t         *        This takes 2 arguments: `function (err, location) { ... }`\n\t         *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var coords = {\n\t         *     latitude: 37.4224764,\n\t         *     longitude: -122.0842499\n\t         * };\n\t         *\n\t         * geolocator.reverseGeocode(coords, function (err, location) {\n\t         *     console.log(err || location);\n\t         * });\n\t         *\n\t         * @example\n\t         * // location result:\n\t         * {\n\t         *     coords: {\n\t         *         latitude: 37.4224764,\n\t         *         longitude: -122.0842499\n\t         *     },\n\t         *     address: {\n\t         *         commonName: \"\",\n\t         *         street: \"Amphitheatre Pkwy\",\n\t         *         route: \"Amphitheatre Pkwy\",\n\t         *         streetNumber: \"1600\",\n\t         *         neighborhood: \"\",\n\t         *         town: \"\",\n\t         *         city: \"Mountain View\",\n\t         *         region: \"Santa Clara County\",\n\t         *         state: \"California\",\n\t         *         stateCode: \"CA\",\n\t         *         postalCode: \"94043\",\n\t         *         country: \"United States\",\n\t         *         countryCode: \"US\"\n\t         *     },\n\t         *     formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n\t         *     type: \"ROOFTOP\",\n\t         *     placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n\t         *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n\t         *     map: {\n\t         *     \t   element: HTMLElement,\n\t         *     \t   instance: Object, // google.maps.Map\n\t         *     \t   marker: Object, // google.maps.Marker\n\t         *     \t   infoWindow: Object, // google.maps.InfoWindow\n\t         *     \t   options: Object // map options\n\t         *     },\n\t         *     timestamp: 1456795956380\n\t         * }\n\t         */\n\t\n\t    }, {\n\t        key: 'reverseGeocode',\n\t        value: function reverseGeocode(options, callback) {\n\t            _geocode(true, options, callback);\n\t        }\n\t\n\t        /**\n\t         *  Alias for `geolocator.reverseGeocode`\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'addressLookup',\n\t        value: function addressLookup(options, callback) {\n\t            geolocator.reverseGeocode(options, callback);\n\t        }\n\t\n\t        /**\n\t         * Gets timezone information for the given coordinates.\n\t         * Note: Google Browser API keys cannot have referer restrictions when used with this API.\n\t         * @see {@link https://developers.google.com/maps/documentation/timezone/intro|Google Maps TimeZone API}\n\t         * @see {@link https://developers.google.com/maps/documentation/timezone/usage-limits|Usage Limits}\n\t         *\n\t         * @param {Object} options\n\t         *        Time zone options.\n\t         *     @param {Number} options.latitude\n\t         *            Latitude of location.\n\t         *     @param {Number} options.longitude\n\t         *            Longitude of location.\n\t         *     @param {Number} [options.timestamp=Date.now()]\n\t         *            Specifies the desired time as seconds since midnight, January\n\t         *            1, 1970 UTC. This is used to determine whether or not Daylight\n\t         *            Savings should be applied.\n\t         *     @param {Boolean} [options.raw=false]\n\t         *            Whether to return the raw Google API result.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes, in\n\t         *        the following signature: `function (err, timezone) { ... }`.\n\t         *        See {@link #geolocator~TimeZone|`geolocator~TimeZone` type} for\n\t         *        details.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var options = {\n\t         *     latitude: 48.8534100,\n\t         *     longitude: 2.3488000\n\t         * };\n\t         * geolocator.getTimeZone(options, function (err, timezone) {\n\t         *     console.log(err || timezone);\n\t         * });\n\t         *\n\t         * @example\n\t         * // timezone result:\n\t         * {\n\t         *     id: \"Europe/Paris\",\n\t         *     name: \"Central European Standard Time\",\n\t         *     abbr: \"CEST\",\n\t         *     dstOffset: 0,\n\t         *     rawOffset: 3600,\n\t         *     timestamp: 1455733120\n\t         * }\n\t         */\n\t\n\t    }, {\n\t        key: 'getTimeZone',\n\t        value: function getTimeZone(options, callback) {\n\t            if (!_utils2.default.isPlainObject(options) || !_utils2.default.isNumber(options.latitude) || !_utils2.default.isNumber(options.longitude)) {\n\t                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS);\n\t            }\n\t\n\t            checkGoogleKey();\n\t\n\t            var conf = geolocator._.config;\n\t            options = _utils2.default.extend({\n\t                key: conf.google.key || '',\n\t                language: conf.language || 'en',\n\t                timestamp: _utils2.default.time(true),\n\t                raw: false\n\t            }, options);\n\t\n\t            var url = _utils2.default.setProtocol(_enums2.default.URL.GOOGLE_TIMEZONE, conf.https),\n\t                xhrOpts = {\n\t                url: url + '?location=' + options.latitude + ',' + options.longitude + '&timestamp=' + options.timestamp + '&language=' + options.language + '&key=' + options.key\n\t            };\n\t\n\t            _fetch2.default.xhr(xhrOpts, function (err, xhr) {\n\t                var response = getXHRResponse(err, xhr);\n\t                if (_geo4.default.isGeoError(response)) return callback(response, null);\n\t\n\t                response = options.raw ? response : {\n\t                    id: response.timeZoneId,\n\t                    name: response.timeZoneName,\n\t                    abbr: _utils2.default.abbr(response.timeZoneName, { dots: false }),\n\t                    dstOffset: response.dstOffset,\n\t                    rawOffset: response.rawOffset,\n\t                    timestamp: options.timestamp\n\t                };\n\t                callback(err, response);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Gets the distance and duration values based on the recommended route\n\t         * between start and end points.\n\t         * @see {@link https://developers.google.com/maps/documentation/distance-matrix/intro|Google Maps Distance Matrix API}\n\t         * @see {@link https://developers.google.com/maps/documentation/distance-matrix/usage-limits|Usage Limits}\n\t         *\n\t         * @param {Object} options\n\t         *        Distance matrix options.\n\t         *     @param {String|Object|Array} options.origins\n\t         *            One or more addresses and/or an object of latitude/longitude\n\t         *            values, from which to calculate distance and time. If you pass\n\t         *            an address as a string, the service will geocode the string\n\t         *            and convert it to a latitude/longitude coordinate to calculate\n\t         *            distances. Following are valid examples:\n\t         * <pre><code>options.origins = 'London';\n\t         * options.origins = ['London', 'Paris'];\n\t         * options.origins = { latitude: 51.5085300, longitude: -0.1257400 };\n\t         * options.origins = [\n\t         *     { latitude: 51.5085300, longitude: -0.1257400 },\n\t         *     { latitude: 48.8534100, longitude: 2.3488000 }\n\t         * ];\n\t         * </code></pre>\n\t         *     @param {String|Object|Array} options.destinations\n\t         *            One or more addresses and/or an object of latitude/longitude\n\t         *            values, from which to calculate distance and time. If you pass\n\t         *            an address as a string, the service will geocode the string\n\t         *            and convert it to a latitude/longitude coordinate to calculate\n\t         *            distances.\n\t         *     @param {String} [options.travelMode=\"DRIVING\"]\n\t         *            Type of routing requested.\n\t         *            See {@link #geolocator.TravelMode|`geolocator.TravelMode` enumeration}\n\t         *            for possible values.\n\t         *     @param {Boolean} [options.avoidFerries]\n\t         *            If true, instructs the Distance Matrix service to avoid\n\t         *            ferries where possible.\n\t         *     @param {Boolean} [options.avoidHighways]\n\t         *            If true, instructs the Distance Matrix service to avoid\n\t         *            highways where possible.\n\t         *     @param {Boolean} [options.avoidTolls]\n\t         *            If true, instructs the Distance Matrix service to avoid toll\n\t         *            roads where possible.\n\t         *     @param {Number} [options.unitSystem=0]\n\t         *            Preferred unit system to use when displaying distance.\n\t         *            See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n\t         *            for possible values.\n\t         *     @param {String} [options.region]\n\t         *            Region code used as a bias for geocoding requests.\n\t         * @param {Boolean} [options.raw=false]\n\t         *        Whether to return the raw Google API result.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes,\n\t         *        in the following signature: `function (err, result) { ... }`\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var options = {\n\t         *     origins: [{ latitude: 51.5085300, longitude: -0.1257400 }],\n\t         *     destinations: [{ latitude: 48.8534100, longitude: 2.3488000 }],\n\t         *     travelMode: geolocator.TravelMode.DRIVING,\n\t         *     unitSystem: geolocator.UnitSystem.METRIC\n\t         * };\n\t         * geolocator.getDistanceMatrix(options, function (err, result) {\n\t         *     console.log(err || result);\n\t         * });\n\t         *\n\t         * @example\n\t         * // result:\n\t         * [\n\t         * \t{\n\t         * \t\tfrom: \"449 Duncannon St, London WC2R 0DZ, UK\",\n\t         * \t\tto: \"1 Parvis Notre-Dame - Pl. Jean-Paul II, 75004 Paris-4E-Arrondissement, France\",\n\t         * \t\tdistance: {\n\t         * \t\t\tvalue: 475104,\n\t         * \t\t\ttext: \"475 km\"\n\t         * \t\t},\n\t         * \t\tduration: {\n\t         * \t\t\tvalue: 20193,\n\t         * \t\t\ttext: \"5 hours 37 mins\"\n\t         * \t\t},\n\t         * \t\tfare: undefined,\n\t         * \t\ttimestamp: 1456795956380\n\t         * \t}\n\t         * ]\n\t         */\n\t\n\t    }, {\n\t        key: 'getDistanceMatrix',\n\t        value: function getDistanceMatrix(options, callback) {\n\t            checkGoogleKey();\n\t\n\t            var key = geolocator._.config.google.key;\n\t            geolocator.ensureGoogleLoaded(key, function (err) {\n\t                if (err) {\n\t                    throw new _geo4.default(_geo4.default.Code.GOOGLE_API_FAILED, String(err.message || err));\n\t                }\n\t\n\t                var o = options.origins || options.origin || options.from,\n\t                    d = options.destinations || options.destination || options.to;\n\t                if (!_utils2.default.isPlainObject(options) || invalidOriginOrDest(o) || invalidOriginOrDest(d)) {\n\t                    throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS);\n\t                }\n\t                options.origins = _geo2.default.toPointList(o);\n\t                options.destinations = _geo2.default.toPointList(d);\n\t\n\t                options = _utils2.default.extend({\n\t                    travelMode: google.maps.TravelMode.DRIVING,\n\t                    avoidFerries: undefined,\n\t                    avoidHighways: undefined,\n\t                    avoidTolls: undefined,\n\t                    unitSystem: google.maps.UnitSystem.METRIC\n\t                }, options);\n\t\n\t                var service = new google.maps.DistanceMatrixService();\n\t                service.getDistanceMatrix(options, function (response, status) {\n\t                    var err = null;\n\t                    if (status !== google.maps.DistanceMatrixStatus.OK) {\n\t                        err = _geo4.default.fromResponse(status) || _geo4.default.fromResponse(response);\n\t                        response = null;\n\t                    } else {\n\t                        response = options.raw ? response : _geo2.default.formatDistanceResults(response);\n\t                    }\n\t                    callback(err, response);\n\t                });\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Calculates the distance between two geographic points.\n\t         *\n\t         * @param {Object} options\n\t         *        Calculation and display options.\n\t         *     @param {Object} options.from\n\t         *            Object containing the `latitude` and `longitude` of original\n\t         *            location.\n\t         *     @param {Object} options.to\n\t         *            Object containing the `latitude` and `longitude` of destination.\n\t         *     @param {String} [options.formula=\"haversine\"]\n\t         *            The algorithm or formula to calculate the distance.\n\t         *            See {@link #geolocator.DistanceFormula|`geolocator.DistanceFormula` enumeration}.\n\t         *     @param {Number} [options.unitSystem=0]\n\t         *            Preferred unit system to use when displaying distance.\n\t         *            See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}.\n\t         *\n\t         * @returns {Number} - The calculated distance.\n\t         *\n\t         * @example\n\t         * // Calculate distance from London to Paris.\n\t         * var result = geolocator.calcDistance({\n\t         *     from: {\n\t         *         latitude: 51.5085300,\n\t         *         longitude: -0.1257400\n\t         *     },\n\t         *     to: {\n\t         *         latitude: 48.8534100,\n\t         *         longitude: 2.3488000\n\t         *     },\n\t         *     formula: geolocator.DistanceFormula.HAVERSINE,\n\t         *     unitSystem: geolocator.UnitSystem.METRIC\n\t         * });\n\t         * // result: 366.41656039126093 (kilometers)\n\t         */\n\t\n\t    }, {\n\t        key: 'calcDistance',\n\t        value: function calcDistance(options) {\n\t            options = _utils2.default.extend({\n\t                formula: geolocator.DistanceFormula.HAVERSINE,\n\t                unitSystem: geolocator.UnitSystem.METRIC\n\t            }, options);\n\t\n\t            var from = options.from,\n\t                to = options.to,\n\t                radius = options.unitSystem === geolocator.UnitSystem.METRIC ? EARTH_RADIUS_KM : EARTH_RADIUS_MI;\n\t\n\t            if (options.formula === geolocator.DistanceFormula.HAVERSINE) {\n\t                var dLat = geolocator.degToRad(to.latitude - from.latitude),\n\t                    dLng = geolocator.degToRad(to.longitude - from.longitude),\n\t                    a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(geolocator.degToRad(from.latitude)) * Math.cos(geolocator.degToRad(to.longitude)) * Math.sin(dLng / 2) * Math.sin(dLng / 2),\n\t                    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t                return radius * c;\n\t            }\n\t            // geolocator.DistanceFormula.PYTHAGOREAN\n\t            var latA = geolocator.degToRad(from.latitude),\n\t                latB = geolocator.degToRad(to.latitude),\n\t                lngA = geolocator.degToRad(from.longitude),\n\t                lngB = geolocator.degToRad(to.longitude),\n\t                x = (lngB - lngA) * Math.cos((latA + latB) / 2),\n\t                y = latB - latA;\n\t            return Math.sqrt(x * x + y * y) * radius;\n\t        }\n\t\n\t        /**\n\t         * Gets the current public IP of the client.\n\t         *\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the request completes, in\n\t         *        the following signature: `function (err, result) { ... }`\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * geolocator.getIP(function (err, result) {\n\t         *     console.log(err || result);\n\t         * });\n\t         *\n\t         * @example\n\t         * // result:\n\t         * {\n\t         *     ip: \"176.232.71.155\",\n\t         *     timestamp: 1457573683427\n\t         * }\n\t         */\n\t\n\t    }, {\n\t        key: 'getIP',\n\t        value: function getIP(callback) {\n\t            var conf = geolocator._.config;\n\t\n\t            var jsonpOpts = {\n\t                url: _utils2.default.setProtocol(_enums2.default.URL.IP, conf.https),\n\t                async: true,\n\t                clean: true,\n\t                params: {\n\t                    format: 'jsonp'\n\t                },\n\t                callbackParam: 'callback',\n\t                rootName: 'geolocator._.cb'\n\t            };\n\t            return _fetch2.default.jsonp(jsonpOpts, function (err, response) {\n\t                if (err) {\n\t                    return callback(_geo4.default.create(err), null);\n\t                }\n\t                if (!response) {\n\t                    err = new _geo4.default(_geo4.default.Code.INVALID_RESPONSE);\n\t                    return callback(err, null);\n\t                }\n\t                if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) === 'object') response.timestamp = _utils2.default.time();\n\t                callback(null, response);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Ensures Google Maps API is loaded. If not, this will load all of the\n\t         * main Javascript objects and symbols for use in the Maps API.\n\t         *\n\t         * Note that, Google Maps API is loaded only when needed. For example,\n\t         * the DistanceMatrix API does not support Web Service requests and\n\t         * requires this API to be loaded. However, the TimeZone API requests are\n\t         * made throught the Web Service without requiring a `google` object\n\t         * within DOM.\n\t         *\n\t         * Also note that this will not re-load the API if `google.maps` object\n\t         * already exists. In this case, the `callback` is still executed and\n\t         * no errors are passed.\n\t         *\n\t         * You can use the following overload to omit the `key` argument altogether:\n\t         *\n\t         * `geolocator.ensureGoogleLoaded(callback)`\n\t         *\n\t         * @param {String} [key]\n\t         *        Google API key.\n\t         * @param {Function} callback\n\t         *        Callback function to be executed when the operation ends.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * geolocator.ensureGoogleLoaded(function (err) {\n\t         * \t   if (err) return;\n\t         * \t   console.log('google' in window); // true\n\t         * });\n\t         */\n\t\n\t    }, {\n\t        key: 'ensureGoogleLoaded',\n\t        value: function ensureGoogleLoaded(key, callback) {\n\t            var k = void 0;\n\t            if (_utils2.default.isFunction(key)) {\n\t                callback = key;\n\t            } else {\n\t                k = key;\n\t            }\n\t            if (!geolocator.isGoogleLoaded()) {\n\t                var jsonpOpts = {\n\t                    url: _enums2.default.URL.GOOGLE_MAPS_API,\n\t                    async: true,\n\t                    callbackParam: 'callback',\n\t                    params: {\n\t                        key: k || ''\n\t                        // callback: ''\n\t                    },\n\t                    rootName: 'geolocator._.cb'\n\t                };\n\t                return _fetch2.default.jsonp(jsonpOpts, callback);\n\t            }\n\t            callback();\n\t        }\n\t\n\t        /**\n\t         * Checks whether the Google Maps API is loaded.\n\t         *\n\t         * @returns {Boolean} - Returns `true` if already loaded.\n\t         */\n\t\n\t    }, {\n\t        key: 'isGoogleLoaded',\n\t        value: function isGoogleLoaded() {\n\t            return 'google' in window && google.maps;\n\t        }\n\t\n\t        /**\n\t         * Checks whether the type of the given object is an HTML5 `PositionError`.\n\t         *\n\t         * @param {*} obj - Object to be checked.\n\t         * @return {Boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isPositionError',\n\t        value: function isPositionError(obj) {\n\t            return _utils2.default.isPositionError(obj);\n\t        }\n\t\n\t        /**\n\t         * Checks whether the given value is an instance of `GeoError`.\n\t         *\n\t         * @param {*} obj - Object to be checked.\n\t         * @return {Boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isGeoError',\n\t        value: function isGeoError(obj) {\n\t            return _geo4.default.isGeoError(obj);\n\t        }\n\t\n\t        /**\n\t         * Checks whether HTML5 Geolocation API is supported.\n\t         *\n\t         * @return {Boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isGeolocationSupported',\n\t        value: function isGeolocationSupported() {\n\t            return navigator && 'geolocation' in navigator;\n\t        }\n\t\n\t        /**\n\t         * Converts kilometers to miles.\n\t         *\n\t         * @param {Number} km - Kilometers to be converted.\n\t         * @returns {Number} - Miles.\n\t         */\n\t\n\t    }, {\n\t        key: 'kmToMi',\n\t        value: function kmToMi(km) {\n\t            return km * 0.621371;\n\t        }\n\t\n\t        /**\n\t         * Converts miles to kilometers.\n\t         *\n\t         * @param {Number} mi - Miles to be converted.\n\t         * @returns {Number} - Kilometers.\n\t         */\n\t\n\t    }, {\n\t        key: 'miToKm',\n\t        value: function miToKm(mi) {\n\t            return mi / 0.621371;\n\t        }\n\t\n\t        /**\n\t         * Converts degrees to radians.\n\t         *\n\t         * @param {Number} deg - Degrees to be converted.\n\t         * @returns {Number} - Radians.\n\t         */\n\t\n\t    }, {\n\t        key: 'degToRad',\n\t        value: function degToRad(degrees) {\n\t            return degrees * (Math.PI / 180);\n\t        }\n\t\n\t        /**\n\t         * Converts radians to degrees.\n\t         *\n\t         * @param {Number} rad - Radians to be converted.\n\t         * @returns {Number} - Degrees.\n\t         */\n\t\n\t    }, {\n\t        key: 'radToDeg',\n\t        value: function radToDeg(radians) {\n\t            return radians * (180 / Math.PI);\n\t        }\n\t\n\t        /**\n\t         * Converts decimal coordinates (either lat or lng) to degrees, minutes, seconds.\n\t         *\n\t         * @param {Number} dec\n\t         *        Decimals to be converted.\n\t         * @param {Boolean} [isLng=false]\n\t         *        Indicates whether the given decimals is longitude.\n\t         *\n\t         * @returns {String} - Degrees, minutes, seconds.\n\t         */\n\t\n\t    }, {\n\t        key: 'decToDegMinSec',\n\t        value: function decToDegMinSec(dec) {\n\t            var isLng = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t            // Degrees Latitude must be in the range of -90. to 90.\n\t            // Degrees Longitude must be in the range of -180 to 180.\n\t            // +Latitude is North, -Latitude is South\n\t            // +Longitude is East, -Longitude is West\n\t            var sign = dec < 0 ? -1 : 1,\n\t                sn = dec < 0 ? 'S' : 'N',\n\t                we = dec < 0 ? 'W' : 'E',\n\t                nsew = !isLng ? sn : we,\n\t                absValue = Math.abs(Math.round(dec * 1000000.0));\n\t            return Math.floor(absValue / 1000000) * sign + '° ' + Math.floor((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60) + '\\' ' + Math.floor(((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60 - Math.floor((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60)) * 100000) * 60 / 100000 + '\" ' + nsew;\n\t        }\n\t    }, {\n\t        key: 'Error',\n\t\n\t\n\t        // ---------------------------\n\t        // PROPERTIES\n\t        // ---------------------------\n\t\n\t        /**\n\t         * Geolocator Error class that provides a common type of error object for\n\t         * the various APIs implemented in Geolocator. All callbacks of Geolocator\n\t         * will include an instance of this object as the first argument; if the\n\t         * corresponding operation fails. Also all thrown errors will be an instance\n\t         * of this object.\n\t         *\n\t         * This object also enumerates\n\t         * {@link ?api=geolocator-error#GeoError.Code|Geolocator Error codes}.\n\t         *\n\t         * @see {@link ?api=geolocator-error|`GeoError` documentation}\n\t         * @type {GeoError}\n\t         * @readonly\n\t         */\n\t        get: function get() {\n\t            return _geo4.default;\n\t        }\n\t\n\t        /**\n\t         * Documented in separately in enums.js\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'MapTypeId',\n\t        get: function get() {\n\t            return _enums2.default.MapTypeId;\n\t        }\n\t\n\t        /**\n\t         * Documented in separately in enums.js\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'LocationType',\n\t        get: function get() {\n\t            return _enums2.default.LocationType;\n\t        }\n\t\n\t        /**\n\t         * Documented in separately in enums.js\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'TravelMode',\n\t        get: function get() {\n\t            return _enums2.default.TravelMode;\n\t        }\n\t\n\t        /**\n\t         * Documented in separately in enums.js\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'UnitSystem',\n\t        get: function get() {\n\t            return _enums2.default.UnitSystem;\n\t        }\n\t\n\t        /**\n\t         * Documented in separately in enums.js\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'RadioType',\n\t        get: function get() {\n\t            return _enums2.default.RadioType;\n\t        }\n\t\n\t        /**\n\t         * Documented in separately in enums.js\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'DistanceFormula',\n\t        get: function get() {\n\t            return _enums2.default.DistanceFormula;\n\t        }\n\t    }]);\n\t\n\t    return geolocator;\n\t}();\n\t\n\t// ---------------------------\n\t// HELPER METHODS\n\t// ---------------------------\n\t\n\t/**\n\t *  Used with distance matrix calls.\n\t *  @private\n\t */\n\t\n\t\n\tfunction invalidOriginOrDest(value) {\n\t    return !_utils2.default.isString(value) && !_utils2.default.isArray(value) && !_utils2.default.isPlainObject(value);\n\t}\n\t\n\t/**\n\t *  Check if XHR response is an error response and returns a `GeoError`.\n\t *  If not, returns the parsed response.\n\t *  @private\n\t *\n\t *  @param {Error} err\n\t *         XHR error.\n\t *  @param {Object} xhr\n\t *         XHR object to be checked.\n\t *\n\t *  @returns {GeoError|Object}\n\t */\n\tfunction getXHRResponse(err, xhr) {\n\t    if (err) return _geo4.default.create(err);\n\t    if (!xhr) return new _geo4.default(_geo4.default.Code.REQUEST_FAILED);\n\t    var response = _utils2.default.safeJsonParse(xhr.responseText);\n\t    // Check if XHR response is an error response.\n\t    // return response if not.\n\t    return _geo4.default.fromResponse(response) || response;\n\t}\n\t\n\t/**\n\t *  Checks the given options and determines if Google key is required.\n\t *  Throws if key is required but not set or valid.\n\t *  @private\n\t *\n\t *  @param {Object} [options]\n\t *         Options to be checked. If `undefined`, directly checks Googke key.\n\t */\n\tfunction checkGoogleKey(options) {\n\t    if (!options || options.addressLookup || options.timezone || options.map) {\n\t        if (!geolocator._.config.google.key) {\n\t            throw new _geo4.default(_geo4.default.Code.GOOGLE_KEY_INVALID, 'A Google API key is required but it\\'s not set or valid.');\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t *  Checks and adds necessary properties to map options from the given location\n\t *  result object. This is used with methods that support `map` option; to\n\t *  create a map from the result coordinates; such as locate() method.\n\t *  @private\n\t *\n\t *  @param {Object|String} options\n\t *         Original options object.\n\t *  @param {Object} location\n\t *         Location result object.\n\t *\n\t *  @returns {Object} - Final map options object.\n\t */\n\tfunction getMapOpts(mapOptions, location) {\n\t    if (_utils2.default.isObject(mapOptions)) {\n\t        mapOptions.center = location.coords;\n\t    } else {\n\t        mapOptions = {\n\t            element: mapOptions,\n\t            center: location.coords\n\t        };\n\t    }\n\t    // this will enable infoWindow\n\t    if (location.formattedAddress) {\n\t        mapOptions.title = location.formattedAddress;\n\t    }\n\t    // if location has accuracy, (and zoom is not set) we can zoom in a bit more\n\t    if (!mapOptions.zoom && location.coords && _utils2.default.isNumber(location.coords.accuracy) && location.coords.accuracy < 1500) {\n\t        mapOptions.zoom = 15;\n\t    }\n\t    return mapOptions;\n\t}\n\t\n\t/**\n\t *  Checks the HTMLElement to see whether a previous map and related objects\n\t *  (marker, infoWindow) are created for it; by checking our private property\n\t *  `_geolocatorMapData`. If there is a map, this does not re-create it (which\n\t *  will break the map) but only re-adjust center, zoom and re-create the marker\n\t *  if needed. We use this approach bec. Google maps has no feature to destroy\n\t *  a map. This is considered a bug by Google developers.\n\t *  @private\n\t *\n\t *  @param {Object} options\n\t *         Options for creating a map.\n\t */\n\tfunction configCreateMap(options) {\n\t    var elem = options.element,\n\t\n\t    // when geolocator creates a map, it will set a `_geolocatorMapData`\n\t    // property on the element. So we can use this map instance later,\n\t    // when the same HTMLElement is passed to create a map. So check if\n\t    // we have it here.\n\t    mapData = elem._geolocatorMapData,\n\t        map = mapData && mapData.instance || null,\n\t        marker = mapData && mapData.marker || null,\n\t        infoWindow = mapData && mapData.infoWindow || null,\n\t        center = new google.maps.LatLng(options.center.latitude, options.center.longitude),\n\t        mapOptions = {\n\t        mapTypeId: options.mapTypeId,\n\t        center: center,\n\t        zoom: options.zoom\n\t    };\n\t\n\t    // if we have a map, we'll just configure it. otherwise, we'll create\n\t    // one.\n\t    if (map) {\n\t        map.setMapTypeId(mapOptions.mapTypeId);\n\t        map.setCenter(mapOptions.center);\n\t        map.setZoom(mapOptions.zoom);\n\t    } else {\n\t        map = new google.maps.Map(options.element, mapOptions);\n\t    }\n\t\n\t    // destroy marker and infoWindow if previously created for this element.\n\t    if (infoWindow) infoWindow = null;\n\t    if (marker && marker instanceof google.maps.Marker) {\n\t        google.maps.event.clearInstanceListeners(marker);\n\t        marker.setMap(null);\n\t        marker = null;\n\t    }\n\t\n\t    // check the new options to see if we need to re-create a marker for\n\t    // this.\n\t    if (options.marker) {\n\t        marker = new google.maps.Marker({\n\t            position: mapOptions.center,\n\t            map: map\n\t        });\n\t        if (options.title) {\n\t            infoWindow = new google.maps.InfoWindow();\n\t            infoWindow.setContent(options.title);\n\t            // infoWindow.open(map, marker);\n\t            google.maps.event.addListener(marker, 'click', function () {\n\t                infoWindow.open(map, marker);\n\t            });\n\t        }\n\t    }\n\t\n\t    mapData = {\n\t        element: elem,\n\t        instance: map,\n\t        marker: marker,\n\t        infoWindow: infoWindow,\n\t        options: mapOptions\n\t    };\n\t    // set the reference on the element for later use, if needed.\n\t    elem._geolocatorMapData = mapData;\n\t    return mapData;\n\t}\n\t\n\t/**\n\t *  Sets the `flag` property of the given location.\n\t *  @private\n\t *\n\t *  @param {Object} location\n\t */\n\tfunction setFlagURL(location) {\n\t    if (!location || !location.address) return;\n\t    var cc = void 0,\n\t        address = location.address;\n\t    if (_utils2.default.isString(address.countryCode) && address.countryCode.length === 2) {\n\t        cc = address.countryCode;\n\t    } else if (_utils2.default.isString(address.country) && address.country.length === 2) {\n\t        cc = address.country;\n\t    }\n\t    if (!cc) return;\n\t    location.flag = _enums2.default.URL.FLAG + cc.toLowerCase() + '.svg';\n\t}\n\t\n\t/**\n\t *  Nests `createMap` callback within the given callback.\n\t *  @private\n\t *\n\t *  @param {Object} options\n\t *         Method options.\n\t *  @param {Function} callback\n\t *         Parent callback.\n\t *\n\t *  @returns {Function} - Nested callback.\n\t */\n\tfunction callbackMap(options, callback) {\n\t    return function cb(err, location) {\n\t        if (err) return callback(_geo4.default.create(err), null);\n\t        setFlagURL(location);\n\t        if (!options.map) return callback(null, location);\n\t        options.map = getMapOpts(options.map, location);\n\t        geolocator.createMap(options.map, function (error, map) {\n\t            if (error) return callback(error, null);\n\t            location.map = map;\n\t            return callback(null, location);\n\t        });\n\t    };\n\t}\n\t\n\t/**\n\t *  Sends a geocode or reverse-geocode request with the given options.\n\t *  @private\n\t *\n\t *  @param {Boolean} reverse\n\t *         Whether to send reverse-geocode request.\n\t *  @param {Object} options\n\t *         Geocode options.\n\t *  @param {Function} callback\n\t *         Callback to be nested and executed with map callback.\n\t */\n\tfunction _geocode(reverse, options, callback) {\n\t    checkGoogleKey();\n\t    _geo2.default.geocode(reverse, geolocator._.config, options, callbackMap(options, callback));\n\t}\n\t\n\t/**\n\t *  Runs both an address and a timezone look-up for the given location.\n\t *  @private\n\t *\n\t *  @param {Object} location\n\t *         Location object.\n\t *  @param {Object} options\n\t *         Method options.\n\t *  @param {Function} callback\n\t *         Parent callback.\n\t */\n\tfunction fetchAddressAndTimezone(location, options, callback) {\n\t    var loc = _utils2.default.clone(location, { own: false });\n\t    if (!options.addressLookup && !options.timezone) {\n\t        return callback(null, loc);\n\t    }\n\t    function getTZ(cb) {\n\t        geolocator.getTimeZone(loc.coords, function (err, timezone) {\n\t            if (err) {\n\t                return cb(err, null);\n\t            }\n\t            delete timezone.timestamp;\n\t            loc.timezone = timezone;\n\t            loc.timestamp = _utils2.default.time(); // update timestamp\n\t            cb(null, loc);\n\t        });\n\t    }\n\t    if (options.addressLookup) {\n\t        geolocator.reverseGeocode(loc.coords, function (err, result) {\n\t            if (err) return callback(err, null);\n\t            loc = _utils2.default.extend({}, result, loc);\n\t            loc.address = result.address;\n\t            loc.timestamp = _utils2.default.time(); // update timestamp\n\t            if (!options.timezone) {\n\t                callback(err, loc);\n\t            } else {\n\t                getTZ(callback);\n\t            }\n\t        });\n\t    } else if (options.timezone) {\n\t        getTZ(callback);\n\t    } else {\n\t        callback(null, loc);\n\t    }\n\t}\n\t\n\t/**\n\t *  Gets the position with better accuracy.\n\t *  See https://github.com/gwilson/getAccurateCurrentPosition#background\n\t *  @private\n\t *\n\t *  @param {Object} options\n\t *         Locate options.\n\t *  @param {Function} onPositionReceived\n\t *         Success callback.\n\t *  @param {Function} onPositionError\n\t *         Error callback.\n\t */\n\tfunction locateAccurate(options, onPositionReceived, onPositionError) {\n\t    var loc = void 0,\n\t        watcher = void 0;\n\t\n\t    function complete() {\n\t        if (!loc) {\n\t            onPositionError(new _geo4.default(_geo4.default.Code.POSITION_UNAVAILABLE));\n\t        } else {\n\t            onPositionReceived(loc);\n\t        }\n\t    }\n\t\n\t    watcher = geolocator.watch(options, function (err, location) {\n\t        if (err) {\n\t            return watcher.clear(function () {\n\t                onPositionError(err);\n\t            });\n\t        }\n\t        if (!loc || location.coords.accuracy <= loc.coords.accuracy) {\n\t            loc = location;\n\t        }\n\t        // ignore the first event if not the only result; for more accuracy.\n\t        if (watcher.cycle > 1 && loc.coords.accuracy <= options.desiredAccuracy) {\n\t            watcher.clear(complete);\n\t        }\n\t    });\n\t    watcher.clear(options.timeout, complete);\n\t}\n\t\n\t// ---------------------------\n\t// INITIALIZE\n\t// ---------------------------\n\t\n\t/**\n\t *  @private\n\t *  @type {Object}\n\t */\n\tgeolocator._ = {\n\t    config: _utils2.default.extend({}, defaultConfig),\n\t    // Storage for global callbacks.\n\t    cb: {}\n\t};\n\t\n\t// setting default Geo-IP source, Wikimedia\n\tgeolocator.setGeoIPSource({\n\t    provider: 'wikimedia',\n\t    url: 'https://bits.wikimedia.org/geoiplookup',\n\t    callbackParam: null,\n\t    globalVar: 'Geo',\n\t    schema: {\n\t        ip: 'IP',\n\t        coords: {\n\t            latitude: 'lat',\n\t            longitude: 'lon'\n\t        },\n\t        address: {\n\t            city: 'city',\n\t            state: 'region',\n\t            stateCode: 'region',\n\t            postalCode: '',\n\t            countryCode: 'country',\n\t            country: 'country',\n\t            region: 'region'\n\t        }\n\t    }\n\t});\n\t\n\t// ---------------------------\n\t// EXPORT\n\t// ---------------------------\n\t\n\texports.default = geolocator;\n\t\n\t// ---------------------------\n\t// ADDITIONAL DOCUMENTATION\n\t// ---------------------------\n\n\t/**\n\t *  Specifies the geographic location of the device. The location is expressed\n\t *  as a set of geographic coordinates together with information about heading\n\t *  and speed.\n\t *\n\t *  @typedef geolocator~Coordinates\n\t *  @type Object\n\t *\n\t *  @property {Number} latitude\n\t *         Specifies the latitude estimate in decimal degrees. The value\n\t *         range is [-90.00, +90.00].\n\t *  @property {Number} longitude\n\t *         Specifies the longitude estimate in decimal degrees. The value\n\t *         range is [-180.00, +180.00].\n\t *  @property {Number} altitude\n\t *         Specifies the altitude estimate in meters above the WGS 84\n\t *         ellipsoid.\n\t *  @property {Number} accuracy\n\t *         Specifies the accuracy of the latitude and longitude estimates in\n\t *         meters.\n\t *  @property {Number} altitudeAccuracy\n\t *         Specifies the accuracy of the altitude estimate in meters.\n\t *  @property {Number} heading\n\t *         Specifies the device's current direction of movement in degrees\n\t *         counting clockwise relative to true north.\n\t *  @property {Number} speed\n\t *         Specifies the device's current ground speed in meters per second.\n\t */\n\n\t/**\n\t *\tSpecifies the address of the fetched location. The address is expressed\n\t *\tas a set of political and locality components.\n\t *\n\t *  @typedef geolocator~Address\n\t *  @type Object\n\t *\n\t *  @property {String} commonName\n\t *         Indicates a point of interest, a premise or colloquial area name for\n\t *         the fetched location, if any.\n\t *  @property {String} streetNumber\n\t *         Indicates the precise street number of the fetched location, if any.\n\t *  @property {String} street\n\t *         Indicates the street name of the fetched location, if any.\n\t *  @property {String} route\n\t *         Indicates the route name of the fetched location, if any.\n\t *  @property {String} neighborhood\n\t *         Indicates the neighborhood name of the fetched location, if any.\n\t *  @property {String} town\n\t *         Indictes the town of the fetched location, if any.\n\t *  @property {String} city\n\t *         Indicates the city of the fetched location.\n\t *  @property {String} region\n\t *         Indicates the political region name of the fetched location, if any.\n\t *  @property {String} postalCode\n\t *         Indicates the postal code of the fetched location, if any.\n\t *  @property {String} state\n\t *         Indicates the state of the fetched location, if any.\n\t *  @property {String} stateCode\n\t *         Indicates the state code of the fetched location, if any.\n\t *  @property {String} country\n\t *         Indicates the national political entity of the fetched location.\n\t *  @property {String} countryCode\n\t *         Indicates the ISO alpha-2 country code of the fetched location.\n\t */\n\n\t/**\n\t *\tSpecifies time offset data for the fetched location on the surface of the\n\t *\tearth.\n\t *\n\t *  @typedef geolocator~TimeZone\n\t *  @type Object\n\t *\n\t *  @property {String} id\n\t *         The ID of the time zone, such as `\"America/Los_Angeles\"` or\n\t *         `\"Australia/Sydney\"`. These IDs are defined in the\n\t *         {@link http://www.iana.org/time-zones|IANA Time Zone Database},\n\t *         which is also available in searchable format in Wikipedia's\n\t *         {@link http://en.wikipedia.org/wiki/List_of_tz_database_time_zones|List of tz database time zones}.\n\t *  @property {String} name\n\t *         The long form name of the time zone. This field will be localized if\n\t *         the Geolocator `language` is configured. e.g. `\"Pacific Daylight Time\"`\n\t *         or `\"Australian Eastern Daylight Time\"`.\n\t *  @property {String} abbr\n\t *         The abbreviation of the time zone.\n\t *  @property {Number} dstOffset\n\t *         The offset for daylight-savings time in seconds. This will be zero\n\t *         if the time zone is not in Daylight Savings Time during the specified\n\t *         timestamp.\n\t *  @property {Number} rawOffset\n\t *         The offset from UTC (in seconds) for the given location. This does\n\t *         not take into effect daylight savings.\n\t */\n\n\t/**\n\t *\tProvides references to the components of a created Google Maps `Map` and\n\t *\tthe containing DOM element.\n\t *\n\t *  @typedef geolocator~MapData\n\t *  @type Object\n\t *\n\t *  @property {HTMLElement} element\n\t *         DOM element which a (Google) map is created within.\n\t *  @property {google.maps.Map} instance\n\t *         Instance of a Google Maps `Map` object.\n\t *  @property {google.maps.Marker} marker\n\t *         Instance of a Google Maps `Marker` object, if any.\n\t *  @property {google.maps.InfoWindow} infoWindow\n\t *         Instance of a Google Maps `InfoWindow` object, if any.\n\t *  @property {Object} options\n\t *         Arbitrary object of applied map options.\n\t */\n\n\t/**\n\t *\tSpecifies geographic coordinates, address and time zone information\n\t *\tfor the fetched location.\n\t *\n\t *  This result object is passed to the callbacks of the corresponding\n\t *  asynchronous Geolocator methods, as the second argument. The contents of\n\t *  this object will differ for various Geolocator methods, depending on the\n\t *  configured method options.\n\t *\n\t *  @typedef geolocator~Location\n\t *  @type Object\n\t *\n\t *  @property {Coordinates} coords\n\t *         Specifies the geographic location of the device. The location is\n\t *         expressed as a set of geographic coordinates together with\n\t *         information about heading and speed.\n\t *         See {@link #geolocator~Coordinates|`geolocator~Coordinates` type}\n\t *         for details.\n\t *  @property {Address} address\n\t *         Specifies the address of the fetched location. The address is\n\t *         expressed as a set of political and locality components.\n\t *         This property might be `undefined` if `addressLookup` option is not\n\t *         enabled for the corresponding method.\n\t *         See {@link #geolocator~Address|`geolocator~Address` type}\n\t *         for details.\n\t *  @property {String} formattedAddress\n\t *         The human-readable address of this location. Often this address is\n\t *         equivalent to the \"postal address,\" which sometimes differs from\n\t *         country to country.\n\t *  @property {Boolean} targetReached\n\t *         Specifies whether the defined target coordinates is reached.\n\t *         This property is only available for\n\t *         {@link #geolocator.watch|`geolocator.watch()`} method when `target`\n\t *         option is defined.\n\t *  @property {String} type\n\t *         Type of the location. See\n\t *         {@link #geolcoator.LocationType|`geolcoator.LocationType` enumeration}\n\t *         for details.\n\t *  @property {String} placeId\n\t *         A unique identifier that can be used with other Google APIs.\n\t *  @property {String} flag\n\t *         URL of the country flag image, in SVG format. This property exists\n\t *         only if address information is available.\n\t *  @property {TimeZone} timezone\n\t *         Specifies time offset data for the fetched location on the surface of\n\t *         the earth. See {@link #geolocator~TimeZone|`geolocator~TimeZone` type}\n\t *         for details.\n\t *  @property {MapData} map\n\t *         Provides references to the components of a created Google Maps `Map`\n\t *         and the containing DOM element. See\n\t *         {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n\t *  @property {Number} timestamp\n\t *         Specifies the time when the location information was retrieved and\n\t *         the `Location` object created.\n\t */\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _toString = Object.prototype.toString;\n\t\n\t/**\n\t * Simple utility methods; internally used within Geolocator core;\n\t * made publically accessible.\n\t * @type {Object}\n\t * @readonly\n\t *\n\t * @license MIT\n\t * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n\t */\n\tvar utils = {\n\t    noop: function noop() {},\n\t\n\t\n\t    // ---------------------------\n\t    // Validation\n\t    // ---------------------------\n\t\n\t    /**\n\t     * Checks if the type of the given value is `String`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isString: function isString(value) {\n\t        return typeof value === 'string';\n\t    },\n\t    isStringSet: function isStringSet(value) {\n\t        return typeof value === 'string' && value.trim().length > 0;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the type of the given value is `Number`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isNumber: function isNumber(value) {\n\t        return typeof value === 'number';\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the type of the given value is an `Object` or `Function`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isObject: function isObject(value) {\n\t        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\t        return Boolean(value) && (type === 'object' || type === 'function');\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the type of the given value is `Function`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isFunction: function isFunction(value) {\n\t        return typeof value === 'function';\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the type of the given value is `Array`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isArray: function isArray(value) {\n\t        return Boolean(value) && _toString.call(value) === '[object Array]';\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the given value is a plain `Object`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isPlainObject: function isPlainObject(value) {\n\t        return Boolean(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && _toString.call(value) === '[object Object]';\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the given value is a `Date`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isDate: function isDate(value) {\n\t        return Boolean(value) && _toString.call(value) === '[object Date]';\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the given object is a DOM element.\n\t     * @memberof utils\n\t     *\n\t     * @param {Object} object - Object to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isElement: function isElement(object) {\n\t        if (!object) return false;\n\t        return object instanceof HTMLElement || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.nodeType === 1;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the given object is a DOM node.\n\t     * @memberof utils\n\t     *\n\t     * @param {Object} object - Object to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isNode: function isNode(object) {\n\t        if (!object) return false;\n\t        return object instanceof Node || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number';\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the given object is a jQuery instance.\n\t     * This will still return `false` if the jQuery instance has no items.\n\t     * @memberof utils\n\t     *\n\t     * @param {Object} object - Object to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isJQueryObject: function isJQueryObject(object) {\n\t        if (!object) return false;\n\t        return 'jQuery' in window && object instanceof window.jQuery && Boolean(object[0]);\n\t        // http://api.jquery.com/jquery-2/\n\t        // || (typeof object === 'object' && Boolean(object.jquery));\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the type of the given value is an HTML5 `PositionError`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isPositionError: function isPositionError(value) {\n\t        return Boolean(value) && _toString.call(value) === '[object PositionError]';\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the given value is an instance of `Error` or HTML5 `PositionError`.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - Value to be checked.\n\t     * @returns {Boolean}\n\t     */\n\t    isError: function isError(value) {\n\t        return value instanceof Error || utils.isPositionError(value);\n\t    },\n\t\n\t\n\t    // ---------------------------\n\t    // String\n\t    // ---------------------------\n\t\n\t    /**\n\t     * Removes the query string portion from the given URL string.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} str - String to be processed.\n\t     * @returns {String} - Returns the rest of the string.\n\t     */\n\t    removeQuery: function removeQuery(str) {\n\t        return str.replace(/\\?.*$/, '');\n\t    },\n\t\n\t\n\t    /**\n\t     * Removes the protocol portion from the given URL string.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} str - String to be processed.\n\t     * @returns {String} - Returns the rest of the string.\n\t     */\n\t    removeProtocol: function removeProtocol(str) {\n\t        return str.replace(/^(.*:)?\\/\\//, '');\n\t    },\n\t\n\t\n\t    /**\n\t     * Sets the protocol of the given URL.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} url - The URL to be modified.\n\t     * @param {Boolean} https - Optional. Default: `undefined`\n\t     * Specifies whether to set the protocol to HTTPS.\n\t     * If omitted, current page protocol will be used.\n\t     * @returns {String} - The modified URL string.\n\t     */\n\t    setProtocol: function setProtocol(url, https) {\n\t        var p = void 0;\n\t        if (https === undefined || https === null) {\n\t            p = window.location.protocol;\n\t        } else {\n\t            p = https ? 'https:' : 'http:';\n\t        }\n\t        url = utils.removeProtocol(url);\n\t        return p + '//' + url;\n\t    },\n\t\n\t\n\t    /**\n\t     * Removes both the leading and trailing dots from the given string.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} str - String to be processed.\n\t     * @returns {String} - Returns the rest of the string.\n\t     */\n\t    trimDots: function trimDots(str) {\n\t        return str.replace(/^\\.+?(.*?)\\.+?$/g, '$1');\n\t    },\n\t\n\t\n\t    /**\n\t     * URL-Encodes the given string. Note that the encoding is done Google's\n\t     * way; that is, spaces are replaced with `+` instead of `%20`.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} str - String to be processed.\n\t     * @returns {String} - Returns the encoded string.\n\t     */\n\t    encodeURI: function encodeURI(str) {\n\t        return encodeURIComponent(str).replace(/%20/g, '+');\n\t    },\n\t\n\t\n\t    /**\n\t     * URL-Decodes the given string. This is the reverse of `utils.encodeURI()`;\n\t     * so pluses (`+`) are replaced with spaces.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} str - String to be processed.\n\t     * @returns {String} - Returns the decoded string.\n\t     */\n\t    decodeURI: function decodeURI(str) {\n\t        return decodeURIComponent(str.replace(/\\+/g, '%20'));\n\t    },\n\t\n\t\n\t    /**\n\t     * Converts the given value to string.\n\t     * null and undefined converts to empty string.\n\t     * If value is a function, it's native `toString()` method is used.\n\t     * Otherwise, value is coerced.\n\t     * @memberof utils\n\t     *\n\t     * @param {*} value - String to be converted.\n\t     * @returns {String} - Returns the result string.\n\t     */\n\t    toString: function toString(value) {\n\t        if (value === null || value === undefined) return '';\n\t        if (value.toString && utils.isFunction(value.toString)) {\n\t            return value.toString();\n\t        }\n\t        return String(value);\n\t    },\n\t\n\t\n\t    /**\n\t     * Generates a random string with the number of characters.\n\t     * @memberof utils\n\t     *\n\t     * @param {Number} len - Optional. Default: `1`.\n\t     * Length of the string.\n\t     * @returns {String} - Returns a random string.\n\t     */\n\t    randomString: function randomString(len) {\n\t        if (!len || !utils.isNumber(len)) len = 1;\n\t        len = -Math.abs(len);\n\t        return Math.random().toString(36).slice(len);\n\t    },\n\t\n\t\n\t    /**\n\t     * Gets the abbreviation of the given phrase.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} str - String to abbreviate.\n\t     * @param {Object} options - Abbreviation options.\n\t     *     @param {Boolean} options.upper - Whether to convert to upper-case.\n\t     *     @param {Boolean} options.dots - Whether to add dots after each abbreviation.\n\t     *\n\t     * @returns {String} - Returns the abbreviation of the given phrase.\n\t     */\n\t    abbr: function abbr(str, options) {\n\t        options = utils.extend({\n\t            upper: true,\n\t            dots: true\n\t        }, options);\n\t        var d = options.dots ? '.' : '',\n\t            s = str.match(/(\\b\\w)/gi).join(d) + d;\n\t        return options.upper ? s.toUpperCase() : s;\n\t    },\n\t\n\t\n\t    /**\n\t     * Builds URI parameters from the given object.\n\t     * Note: This does not iterate deep objects.\n\t     * @memberof utils\n\t     *\n\t     * @param {Object} obj - Object to be processed.\n\t     * @param {Object} options - Parameterize options.\n\t     *     @param {Boolean} options.encode - Optional. Default: `true`.\n\t     *     Whether to encode URI components.\n\t     *     @param {String} options.operator - Optional. Default: `\"=\"`.\n\t     *     @param {String} options.separator - Optional. Default: `\"&\"`.\n\t     *     @param {Array} options.include - Optional. Default: `undefined`.\n\t     *     Keys to be included in the output params. If defined,\n\t     *     `options.exclude` is ignored.\n\t     *     @param {Array} options.exclude - Optional. Default: `undefined`.\n\t     *     Keys to be excluded from the output params.\n\t     *\n\t     * @returns {String} - URI parameters string.\n\t     */\n\t    params: function params(obj, options) {\n\t        if (!utils.isPlainObject(obj) || Object.keys(obj).length === 0) {\n\t            return '';\n\t        }\n\t\n\t        options = utils.extend({\n\t            encode: true,\n\t            operator: '=',\n\t            separator: '&',\n\t            include: undefined,\n\t            exclude: undefined\n\t        }, options);\n\t\n\t        var params = [],\n\t            inc = utils.isArray(options.include) ? options.include : null,\n\t            exc = !inc && utils.isArray(options.exclude) ? options.exclude : null;\n\t        utils.forIn(obj, function (value, key) {\n\t            if ((!inc || inc.indexOf(key) >= 0) && (!exc || exc.indexOf(key) < 0)) {\n\t                var v = utils.toString(value);\n\t                v = options.encode ? utils.encodeURI(v) : v;\n\t                var k = options.encode ? utils.encodeURI(key) : key;\n\t                params.push(k + options.operator + v);\n\t            }\n\t        });\n\t\n\t        return params.join(options.separator);\n\t    },\n\t\n\t\n\t    /**\n\t     * Gets the object from the given object notation string.\n\t     * @private\n\t     *\n\t     * @param {String} notation - Object notation.\n\t     * @returns {*} - Any existing object.\n\t     */\n\t    notateGlobalObj: function notateGlobalObj(notation) {\n\t        notation = utils.trimDots(notation);\n\t        var levels = notation.split('.'),\n\t            o = window;\n\t        if (levels[0] === 'window' || levels[0] === 'document') {\n\t            levels.shift();\n\t        }\n\t        levels.forEach(function (note) {\n\t            o = o[note];\n\t        });\n\t        return o;\n\t    },\n\t\n\t\n\t    // ---------------------------\n\t    // Object\n\t    // ---------------------------\n\t\n\t    /**\n\t     * Iterates over own properties of an object invoking a callback for each\n\t     * property.\n\t     * @memberof utils\n\t     *\n\t     * @param {Object} obj - Object to be processed.\n\t     * @param {Function} callback - Callback function with the following\n\t     * signature: `function (value, key, object) { ... }`.\n\t     * Explicitly returning `false` will exit the iteration early.\n\t     * @returns {void}\n\t     */\n\t    forIn: function forIn(obj, callback) {\n\t        var k = void 0;\n\t        for (k in obj) {\n\t            // if (obj.hasOwnProperty(k)) {} // Do this inside callback if needed.\n\t            if (callback(obj[k], k, obj) === false) break;\n\t        }\n\t    },\n\t\n\t\n\t    /**\n\t     * Extends the given object with the specified sources.\n\t     * Right most source overwrites the previous.\n\t     * NOTE: This is not a full implementation. Use with caution.\n\t     * @memberof utils\n\t     *\n\t     * @param {Object} destination - Destionation Object that will be extended\n\t     * and holds the default values.\n\t     * @param {...Object} sources - Source objects to be merged.\n\t     * @returns {Object} - Returns the extended object.\n\t     */\n\t    extend: function extend(destination) {\n\t        if (!utils.isObject(destination)) return {};\n\t        var key = void 0,\n\t            value = void 0;\n\t\n\t        for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t            sources[_key - 1] = arguments[_key];\n\t        }\n\t\n\t        sources.forEach(function (source) {\n\t            for (key in source) {\n\t                // eslint-disable-line\n\t                value = source[key];\n\t                if (utils.isArray(value)) {\n\t                    destination[key] = value.concat();\n\t                } else if (utils.isDate(value)) {\n\t                    destination[key] = new Date(value);\n\t                } else if (utils.isObject(value)) {\n\t                    destination[key] = utils.extend({}, value);\n\t                } else {\n\t                    destination[key] = value;\n\t                }\n\t            }\n\t        });\n\t        return destination;\n\t    },\n\t\n\t\n\t    /**\n\t     * Clones the given object.\n\t     * NOTE: This is not a full implementation. Use with caution.\n\t     * @memberof utils\n\t     *\n\t     * @param {Object} obj - Target Object to be cloned.\n\t     * @param {Object|Array} options - Optional. Clone options or array of keys\n\t     * to be cloned.\n\t     *     @param {Array} options.keys - Optional. Default: `undefined`.\n\t     *     Keys of the properties to be cloned.\n\t     *     @param {Boolean} options.own - Optional. Default: `true`.\n\t     *     Whether to clone own properties only. This is only effective if\n\t     *     `keys` is not defined.\n\t     * @returns {Object} - Returns the cloned object.\n\t     */\n\t    clone: function clone(obj, options) {\n\t        if (!obj) return {};\n\t\n\t        if (utils.isArray(options)) {\n\t            options = { keys: options };\n\t        }\n\t        options = utils.extend({\n\t            keys: null,\n\t            own: true\n\t        }, options);\n\t\n\t        var include = void 0,\n\t            cloned = {};\n\t\n\t        utils.forIn(obj, function (value, key) {\n\t            include = options.keys ? options.keys.indexOf(key) >= 0 : options.own && obj.hasOwnProperty(key) || !options.own;\n\t            if (include) {\n\t                if (utils.isObject(value)) {\n\t                    cloned[key] = utils.clone(value, options);\n\t                } else {\n\t                    cloned[key] = value;\n\t                }\n\t            }\n\t        });\n\t        return cloned;\n\t    },\n\t\n\t\n\t    /**\n\t     *  Maps the values of the given object to a schema to re-structure a new\n\t     *  object.\n\t     *  @memberof utils\n\t     *\n\t     *  @param {Object} obj - Original object to be mapped.\n\t     *  @param {Object} schema - Schema to be used to map the object.\n\t     *  @returns {Object} - Mapped object.\n\t     */\n\t    mapToSchema: function mapToSchema(obj, schema) {\n\t        var mapped = {};\n\t        utils.forIn(schema, function (value, key) {\n\t            if (utils.isPlainObject(value)) {\n\t                // TODO: dot notation in schema values???\n\t                mapped[key] = utils.mapToSchema(obj, value);\n\t            } else {\n\t                mapped[key] = obj[value];\n\t            }\n\t        });\n\t        return mapped;\n\t    },\n\t\n\t\n\t    // ---------------------------\n\t    // Misc\n\t    // ---------------------------\n\t\n\t    /**\n\t     * Safely parses the given JSON `String` into an `Object`.\n\t     * The only difference from `JSON.parse()` is that this method does not\n\t     * throw for invalid input. Instead, returns `null`.\n\t     * @memberof utils\n\t     *\n\t     * @param {String} str - JSON string to be parsed\n\t     * @returns {Object|null} - Returns the parsed `Object` or `null` if the\n\t     * input is invalid.\n\t     */\n\t    safeJsonParse: function safeJsonParse(str) {\n\t        var o = null;\n\t        try {\n\t            o = JSON.parse(str);\n\t        } catch (e) {}\n\t        return o;\n\t    },\n\t\n\t\n\t    /**\n\t     * Gets a timestamp that is seconds or milliseconds since midnight,\n\t     * January 1, 1970 UTC.\n\t     * @memberof utils\n\t     *\n\t     * @param {Boolean} seconds - Optional. Default: `false`.\n\t     * Specifies whether seconds should be returned instead of milliseconds.\n\t     * @returns {Number} - Returns seconds or milliseconds since midnight,\n\t     * January 1, 1970 UTC.\n\t     */\n\t    time: function time(seconds) {\n\t        var ts = Date.now();\n\t        return seconds ? parseInt(ts / 1000, 10) : ts;\n\t    }\n\t};\n\t\n\texports.default = utils;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Utility for making `XMLHttpRequest` and `JSONP` requests.\n\t *\n\t * @license MIT\n\t * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n\t */\n\t\n\tvar fetch = function () {\n\t    function fetch() {\n\t        _classCallCheck(this, fetch);\n\t    }\n\t\n\t    _createClass(fetch, null, [{\n\t        key: 'jsonp',\n\t\n\t\n\t        // https://html.spec.whatwg.org/multipage/scripting.html#script\n\t\n\t        /**\n\t         * Makes a JSONP (GET) request by injecting a script tag in the browser.\n\t         * Note that using JSONP has some security implications. As JSONP is really\n\t         * javascript, it can do everything else javascript can do, so you need to\n\t         * trust the provider of the JSONP data.\n\t         * @see https://en.wikipedia.org/wiki/JSONP\n\t         * @memberof fetch\n\t         *\n\t         * @param {Object|String} options - Required. Either the URL string which\n\t         *     will set other options to defaults or an options object with the\n\t         *     following properties.\n\t         *     @param {String} options.url - Required. Source URL to be called.\n\t         *     @param {String} options.type - Optional. Default: `undefined`.\n\t         *     The MIME type that identifies the scripting language of the code\n\t         *     referenced within the script element. e.g. `\"text/javascript\"`\n\t         *     @param {String} options.charset - Optional. Default: `undefined`.\n\t         *     Indicates the character encoding of the external resource. e.g. `\"utf-8\"`.\n\t         *     @param {Boolean} options.async - Optional. Default: `true`.\n\t         *     Indicates whether or not to perform the operation asynchronously.\n\t         *     See {@link http://caniuse.com/#feat=script-async|browser support}.\n\t         *     @param {Boolean} options.defer - Optional. Default: `false`.\n\t         *     Indicates whether the script should be executed when the page has\n\t         *     finished parsing. See {@link http://caniuse.com/#feat=script-defer|browser support}.\n\t         *     @param {String} options.crossorigin - Optional. Default: `undefined`.\n\t         *     Indicates the CORS setting for the script element being injected.\n\t         *     Note that this attribute is not widely supported.\n\t         *     Valid values: `\"anonymous\"`, `\"use-credentials\"`.\n\t         *     See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes|CORS settings}.\n\t         *     @param {Number} options.timeout - Optional. Default: `0` (no timeout).\n\t         *     The number of milliseconds a request can take before automatically\n\t         *     being terminated.\n\t         *     @param {Boolean} options.clean - Optional. Default: `false`.\n\t         *     Whether to remove the loaded script from DOM when the operation ends.\n\t         *     Note that the initial source might load additional sources which are\n\t         *     not deteceted or removed. Only the initial source is removed.\n\t         *     @param {Object} options.params - Optional. Default: `undefined`.\n\t         *     Optional query parameters to be appended at the end of the URL.\n\t         *     e.g. `{ key: \"MY-KEY\" }`\n\t         *     You can also include the JSONP callback name parameter here but\n\t         *     if you want the object to be passed to the callback argument of this\n\t         *     method, use `options.callbackParam` to set the callback parameter.\n\t         *     @param {String} options.callbackParam - Optional. Default: `undefined`.\n\t         *     If the endpoint supports JSONP callbacks, you can set the callback\n\t         *     parameter with this setting. This will enable a second `obj` argument\n\t         *     in the callback of this method which is useful if the JSONP source\n\t         *     invokes the callback with an argument.\n\t         *     @param {String} options.rootName - Optional. Default: `undefined`.\n\t         *     The name (or notation) of the object that the generated JSONP\n\t         *     callback function should be assigned to. By default, this is the\n\t         *     `window` object but you can set this to a custom object notation;\n\t         *     for example, to prevent global namespace polution. Note that this\n\t         *     root object has to be globally accessible for this to work.\n\t         *     e.g. `\"window.myObject\"` (as string)\n\t         * @param {Function} callback - Optional. The callback function that will be\n\t         * executed when the script is loaded. This callback has the following\n\t         * signature: `function (err, obj) { ... }`. Note that the second argument\n\t         * `obj` will always be `undefined` if the source endpoint does not support\n\t         * JSONP callbacks or a callback param is not set explicitly via\n\t         * `options.callbackParam` (or if the source does not invoke the jsonp with an\n\t         * argument). However, the function will always execute when the script\n\t         * loads or an error occurs.\n\t         *\n\t         * @returns {void}\n\t         *\n\t         * @example\n\t         * var opts1 = {\n\t         * \turl: 'some/api',\n\t         * \tcallbackParam: 'jsonCallback',\n\t         * \tparams: { key: 'MY-KEY' }\n\t         * };\n\t         * // This will load the following source:\n\t         * // some/api?jsonCallback={auto-generated-fn-name}&key=MY-KEY\n\t         * fetch.jsonp(opts1, function (err, obj) {\n\t         * \tconsole.log(obj); // some object\n\t         * });\n\t         *\n\t         * var opts2 = {\n\t         * \turl: 'some/api',\n\t         * \tparams: {\n\t         * \t\tkey: 'MY-KEY',\n\t         * \t\tjsonCallback: 'my-fn-name'\n\t         * \t}\n\t         * };\n\t         * // This will load the following source:\n\t         * // some/api?jsonCallback=my-fn-name&key=MY-KEY\n\t         * fetch.jsonp(options, function (err, obj) {\n\t         * \tconsole.log(obj); // undefined\n\t         * \t// still executes, catch errors here\n\t         * });\n\t         * // JSON callback should be explicitly set.\n\t         * window['my-fn-name'] = function (obj) {\n\t         * \tconsole.log(obj); // some object\n\t         * };\n\t         */\n\t        value: function jsonp(options, callback) {\n\t            var timeout = void 0;\n\t\n\t            callback = _utils2.default.isFunction(callback) ? callback : _utils2.default.noop;\n\t\n\t            if (_utils2.default.isString(options)) {\n\t                options = { url: options };\n\t            }\n\t\n\t            if (_utils2.default.isPlainObject(options)) {\n\t                options = _utils2.default.extend({\n\t                    // type: undefined,\n\t                    async: true,\n\t                    defer: false,\n\t                    // crossorigin: undefined,\n\t                    timeout: 0,\n\t                    params: {},\n\t                    // callbackParam: undefined,\n\t                    // rootName: undefined,\n\t                    clean: true\n\t                }, options);\n\t            } else {\n\t                return callback(new Error('No options or target URL is provided.'));\n\t            }\n\t\n\t            if (_utils2.default.isString(options.url) === false || options.url.trim() === '') {\n\t                return callback(new Error('No target URL is provided.'));\n\t            }\n\t\n\t            var script = document.createElement('script'),\n\t                cbParamSet = _utils2.default.isString(options.callbackParam) && options.callbackParam.trim() !== '',\n\t                cbFnName = void 0,\n\t                root = void 0,\n\t                rootNameSet = _utils2.default.isString(options.rootName) && options.rootName !== 'window' && options.rootName !== 'document' && options.rootName.trim() !== '';\n\t\n\t            if (cbParamSet) {\n\t                cbFnName = '_jsonp_' + _utils2.default.randomString(10);\n\t                options.params[options.callbackParam] = rootNameSet ? options.rootName + '.' + cbFnName : cbFnName;\n\t            }\n\t            var query = _utils2.default.params(options.params) || '',\n\t                qMark = options.url.indexOf('?') >= 0 ? '&' : '?',\n\t                url = query ? '' + options.url + qMark + query : options.url;\n\t            // console.log(url);\n\t\n\t            function execCb(err, timeUp, obj) {\n\t                if (timeout) {\n\t                    clearTimeout(timeout);\n\t                    timeout = null;\n\t                }\n\t                if ((timeUp || options.clean) && script.parentNode) {\n\t                    script.parentNode.removeChild(script);\n\t                }\n\t                // delete the jsonp callback function\n\t                if (rootNameSet) {\n\t                    delete root[cbFnName];\n\t                }\n\t                callback(err, obj);\n\t            }\n\t\n\t            if (cbFnName) {\n\t                var fn = function fn(obj) {\n\t                    execCb(null, false, obj);\n\t                };\n\t                root = rootNameSet\n\t                // ? window[options.rootName][cbFnName] = fn;\n\t                ? _utils2.default.notateGlobalObj(options.rootName) // if rootName is dot-notation.\n\t                : window;\n\t                root[cbFnName] = fn;\n\t            } else if (script.readyState) {\n\t                // IE < 11\n\t                script.onreadystatechange = function () {\n\t                    if (script.readyState === 'loaded' || script.readyState === 'complete') {\n\t                        script.onreadystatechange = null;\n\t                        execCb(null);\n\t                    }\n\t                };\n\t            } else {\n\t                // IE 11+\n\t                script.onload = function () {\n\t                    execCb(null);\n\t                };\n\t            }\n\t\n\t            script.onerror = function (error) {\n\t                var errMsg = 'Could not load source at ' + _utils2.default.removeQuery(options.url);\n\t                if (error) {\n\t                    errMsg += '\\n' + (error.message || error);\n\t                }\n\t                execCb(new Error(errMsg));\n\t            };\n\t\n\t            if (options.type) {\n\t                script.type = options.type;\n\t            }\n\t            if (options.charset) {\n\t                script.charset = options.charset;\n\t            }\n\t            if (options.async) {\n\t                script.async = true;\n\t            }\n\t            if (options.defer) {\n\t                script.defer = true;\n\t            }\n\t            if (options.crossorigin) {\n\t                script.crossorigin = options.crossorigin;\n\t            }\n\t\n\t            script.src = url;\n\t            document.getElementsByTagName('head')[0].appendChild(script);\n\t\n\t            // Timeout\n\t            if (_utils2.default.isNumber(options.timeout) && options.timeout > 0) {\n\t                timeout = setTimeout(function () {\n\t                    script.src = '';\n\t                    execCb(new Error('Operation timed out.'), true);\n\t                }, options.timeout);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Makes an XMLHttpRequest with the given parameters.\n\t         * Note that `\"Access-Control-Allow-Origin\"` header should be present on\n\t         * the requested resource. Otherwise, the request will not be allowed.\n\t         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}.\n\t         * @memberof fetch\n\t         *\n\t         * @param {Object|String} options - Required. Either the URL string which\n\t         *     will set other options to defaults or the full options object.\n\t         *     @param {String} options.url - Required. Target URL to be called.\n\t         *     @param {String} options.method - Default: `\"GET\"`. HTTP method.\n\t         *     @param {*} options.data - Optional. Default: `undefined`.\n\t         *     Data to be sent with the request, if the HTTP method is set to \"POST\".\n\t         *     @param {Number} options.timeout - Optional. Default: `0` (no timeout).\n\t         *     The number of milliseconds a request can take before automatically\n\t         *     being terminated.\n\t         *     @param {Boolean} options.withCredentials - Optional. Default: `false`.\n\t         *     Indicates whether or not cross-site Access-Control requests should\n\t         *     be made using credentials such as cookies or authorization headers.\n\t         *     @param {Boolean} options.async - Optional. Default: `true`.\n\t         *     Indicating whether or not to perform the operation asynchronously.\n\t         *     If this value is false, the `send()` method does not return until\n\t         *     the response is received. If `true`, notification of a completed\n\t         *     transaction is provided using event listeners. This must be `true`\n\t         *     if the multipart attribute is `true`, or an exception will be thrown.\n\t         *     @param {String} options.mimeType - Optional. Default: `undefined`.\n\t         *     If set, overrides the MIME type returned by the server. This may be\n\t         *     used, for example, to force a stream to be treated and parsed as\n\t         *     `text/xml`, even if the server does not report it as such.\n\t         *     @param {Object} options.headers - Optional. Default: `undefined`.\n\t         *     Sets the HTTP request headers. Each key should be a header name\n\t         *     with a value. e.g. `{ 'Content-Length': 50 }`. For security reasons,\n\t         *     some headers cannot be set and can only be controlled by the user agent.\n\t         *     @param {String} options.username - Optional. Default: `\"\"`.\n\t         *     User name to use for authentication purposes.\n\t         *     @param {String} options.password - Optional. Default: `\"\"`.\n\t         *     Password to use for authentication purposes.\n\t         * @param {Function} callback - Optional. The callback function in the\n\t         *     following signature: `function (err, xhr) { ... }`\n\t         *     Note that `xhr` object is always passed regardless of an error.\n\t         *\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: 'xhr',\n\t        value: function xhr(options, callback) {\n\t            var xhr = void 0,\n\t                err = void 0;\n\t\n\t            if ('XMLHttpRequest' in window) {\n\t                xhr = new XMLHttpRequest();\n\t            } else {\n\t                throw new Error('XMLHttpRequest is not supported!');\n\t            }\n\t\n\t            var hasCallback = _utils2.default.isFunction(callback);\n\t            callback = hasCallback ? callback : _utils2.default.noop;\n\t\n\t            if (_utils2.default.isString(options)) {\n\t                options = { url: options };\n\t            }\n\t\n\t            if (_utils2.default.isPlainObject(options)) {\n\t                options = _utils2.default.extend({\n\t                    method: 'GET',\n\t                    data: undefined,\n\t                    async: true,\n\t                    timeout: 0, // no timeout\n\t                    withCredentials: false,\n\t                    mimeType: undefined,\n\t                    username: '',\n\t                    password: ''\n\t                }, options);\n\t            } else {\n\t                callback(new Error('No options or target URL is provided.'));\n\t            }\n\t\n\t            if (_utils2.default.isString(options.url) === false) {\n\t                callback(new Error('No target URL is provided.'));\n\t            }\n\t\n\t            options.username = String(options.username);\n\t            options.password = String(options.password);\n\t            options.method = options.method.toUpperCase();\n\t            if (options.method !== 'POST' && options.method !== 'PUT') {\n\t                options.data = undefined;\n\t            }\n\t            // console.log(JSON.stringify(options));\n\t\n\t            if (hasCallback) {\n\t                xhr.onreadystatechange = function () {\n\t                    if (xhr.readyState === fetch.XHR_READY_STATE.DONE) {\n\t                        if (xhr.status === 200) {\n\t                            callback(null, xhr);\n\t                        } else {\n\t                            // let response = utils.safeJsonParse(xhr.responseText);\n\t                            // if (response && response.error)\n\t                            var crossDomain = xhr.status === 0 ? '. Make sure you have permission if this is a cross-domain request.' : '';\n\t                            err = new Error('The request returned status: ' + xhr.status + crossDomain);\n\t                            // console.log(xhr);\n\t                            callback(err, xhr);\n\t                        }\n\t                    }\n\t                };\n\t\n\t                if (_utils2.default.isNumber(options.timeout) && options.timeout > 0) {\n\t                    xhr.timeout = options.timeout;\n\t                    xhr.ontimeout = function () {\n\t                        // xhr.abort();\n\t                        err = new Error('The request had timed out.');\n\t                        callback(err, xhr);\n\t                    };\n\t                }\n\t            }\n\t            // console.log(options);\n\t            xhr.open(options.method, options.url, options.async, options.username, options.password);\n\t\n\t            // xhr.setRequestHeader() method should b called œafter open(), but\n\t            // before send().\n\t            if (_utils2.default.isPlainObject(options.headers)) {\n\t                Object.keys(options.headers).forEach(function (key) {\n\t                    var value = options.headers[key];\n\t                    xhr.setRequestHeader(key, value);\n\t                });\n\t            }\n\t\n\t            // xhr.overrideMimeType() method must be called before send().\n\t            if (options.mimeType) {\n\t                xhr.overrideMimeType(options.mimeType);\n\t            }\n\t\n\t            xhr.send(options.data);\n\t        }\n\t\n\t        /**\n\t         * Alias of `fetch.xhr()` with request method set to `\"GET\"` by default.\n\t         * @memberof fetch\n\t         *\n\t         * @param {Object} options - Required. Either the URL string which\n\t         * will set other options to defaults or the full options object.\n\t         * See `fetch.xhr()` method options for details.\n\t         * @param {Function} callback - Optional. The callback function in the\n\t         * following signature: `function (err, xhr) { ... }`\n\t         * Note that `xhr` object is always passed regardless of an error.\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: 'get',\n\t        value: function get(options, callback) {\n\t            return fetch.xhr(options, callback);\n\t        }\n\t\n\t        /**\n\t         * Alias of `fetch.xhr()` with request method set to `\"POST\"` by default.\n\t         * @memberof fetch\n\t         *\n\t         * @param {Object} options - Required. Either the URL string which\n\t         * will set other options to defaults or the full options object.\n\t         * See `fetch.xhr()` method options for details.\n\t         * @param {Function} callback - Optional. The callback function in the\n\t         * following signature: `function (err, xhr) { ... }`\n\t         * Note that `xhr` object is always passed regardless of an error.\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: 'post',\n\t        value: function post(options, callback) {\n\t            return _xhr('POST', options, callback);\n\t        }\n\t\n\t        /**\n\t         * Alias of `fetch.xhr()` with request method set to `\"PUT\"` by default.\n\t         * @memberof fetch\n\t         *\n\t         * @param {Object} options - Required. Either the URL string which\n\t         * will set other options to defaults or the full options object.\n\t         * See `fetch.xhr()` method options for details.\n\t         * @param {Function} callback - Optional. The callback function in the\n\t         * following signature: `function (err, xhr) { ... }`\n\t         * Note that `xhr` object is always passed regardless of an error.\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: 'put',\n\t        value: function put(options, callback) {\n\t            return _xhr('PUT', options, callback);\n\t        }\n\t\n\t        /**\n\t         * Alias of `fetch.xhr()` with request method set to `\"DELETE\"` by default.\n\t         * @memberof fetch\n\t         *\n\t         * @param {Object} options - Required. Either the URL string which\n\t         * will set other options to defaults or the full options object.\n\t         * See `fetch.xhr()` method options for details.\n\t         * @param {Function} callback - Optional. The callback function in the\n\t         * following signature: `function (err, xhr) { ... }`\n\t         * Note that `xhr` object is always passed regardless of an error.\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: 'delete',\n\t        value: function _delete(options, callback) {\n\t            return _xhr('DELETE', options, callback);\n\t        }\n\t    }]);\n\t\n\t    return fetch;\n\t}();\n\t\n\t/**\n\t *  @private\n\t */\n\t\n\t\n\tfunction _xhr(method, options, callback) {\n\t    options = _utils2.default.isString(options) ? { url: options } : options || {};\n\t    options.method = method;\n\t    return fetch.xhr(options, callback);\n\t}\n\t\n\t/**\n\t * Enumerates `XMLHttpRequest` ready states.\n\t * Not to be confused with `script.readyState`.\n\t * @memberof fetch\n\t *\n\t * @enum {Number}\n\t */\n\tfetch.XHR_READY_STATE = {\n\t    /**\n\t     * `xhr.open()` has not been called yet.\n\t     * @type {Number}\n\t     */\n\t    UNSENT: 0,\n\t    /**\n\t     * `xhr.send()` has been called.\n\t     * @type {Number}\n\t     */\n\t    OPENED: 1,\n\t    /**\n\t     * `xhr.send()` has been called, and headers and status are available.\n\t     * @type {Number}\n\t     */\n\t    HEADERS_RECEIVED: 2,\n\t    /**\n\t     * Downloading; responseText holds partial data.\n\t     * @type {Number}\n\t     */\n\t    LOADING: 3,\n\t    /**\n\t     * The operation is complete.\n\t     * @type {Number}\n\t     */\n\t    DONE: 4\n\t};\n\t\n\t// aliases\n\t// fetch.script = fetch.jsonp;\n\t// fetch.ajax = fetch.xhr;\n\t\n\texports.default = fetch;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tvar _fetch = __webpack_require__(3);\n\t\n\tvar _fetch2 = _interopRequireDefault(_fetch);\n\t\n\tvar _enums = __webpack_require__(5);\n\t\n\tvar _enums2 = _interopRequireDefault(_enums);\n\t\n\tvar _geo = __webpack_require__(6);\n\t\n\tvar _geo2 = _interopRequireDefault(_geo);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t *  Helper methods.\n\t *\n\t *  @license MIT\n\t *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n\t *  @type {Object}\n\t *  @private\n\t */\n\tvar geoHelper = {\n\t    toGoogleCoords: function toGoogleCoords(coords) {\n\t        return {\n\t            lat: coords.lat || coords.latitude,\n\t            lng: coords.lng || coords.longitude\n\t        };\n\t    },\n\t    fromGoogleCoords: function fromGoogleCoords(coords) {\n\t        return {\n\t            latitude: coords.latitude || coords.lat,\n\t            longitude: coords.longitude || coords.lng\n\t        };\n\t    },\n\t\n\t\n\t    // used for distance matrix origins and destinations\n\t    toPointList: function toPointList(arr) {\n\t        arr = _utils2.default.isArray(arr) ? arr : [arr];\n\t        return arr.map(function (o) {\n\t            return _utils2.default.isString(o) ? o : geoHelper.toGoogleCoords(o);\n\t        });\n\t    },\n\t    getGeocodeComps: function getGeocodeComps(comp) {\n\t        return {\n\t            route: comp.route,\n\t            locality: comp.locality,\n\t            administrative_area: comp.administrativeArea, // eslint-disable-line camelcase\n\t            postal_code: comp.postalCode, // eslint-disable-line camelcase\n\t            country: comp.country,\n\t            region: comp.region\n\t        };\n\t    },\n\t\n\t\n\t    // Geocode examples:\n\t    // address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=API_KEY\n\t    // address=Winnetka&bounds=34.172684,-118.604794|34.236144,-118.500938&key=API_KEY\n\t    // address=santa+cruz&components=country:ES&key=API_KEY\n\t    // components=administrative_area:TX|country:US&key=API_KEY\n\t    // Reverse Geocode examples:\n\t    // latlng=40.714224,-73.961452&key=API_KEY\n\t    // place_id=ChIJd8BlQ2BZwokRAFUEcm_qrcA&key=API_KEY\n\t    buildGeocodeParams: function buildGeocodeParams(options, reverse) {\n\t        var params = [],\n\t            e = _utils2.default.encodeURI;\n\t\n\t        if (reverse) {\n\t            if (options.placeId) {\n\t                params.push('place_id=' + options.placeId);\n\t            } else if (options.latitude && options.longitude) {\n\t                params.push('latlng=' + options.latitude + ',' + options.longitude);\n\t            }\n\t        } else {\n\t            if (options.address) {\n\t                params.push('address=' + e(options.address));\n\t            }\n\t\n\t            var geoComps = geoHelper.getGeocodeComps(options);\n\t            geoComps = _utils2.default.params(geoComps, { operator: ':', separator: '|' });\n\t            params.push('components=' + geoComps);\n\t\n\t            var b = options.bounds;\n\t            if (_utils2.default.isArray(b) && b.length === 4) {\n\t                params.push('bounds=' + b[0] + ',' + b[1] + '|' + b[2] + ',' + b[3]);\n\t            } else if (_utils2.default.isPlainObject(b) && Object.keys(b).length === 4) {\n\t                params.push('bounds=' + b.southwestLat + ',' + b.southwestLng + '|' + b.northeastLat + ',' + b.northeastLng);\n\t            }\n\t        }\n\t\n\t        params.push('language=' + options.language);\n\t        params.push('key=' + options.key);\n\t        return params.join('&');\n\t    },\n\t\n\t\n\t    // See https://developers.google.com/maps/documentation/geocoding/intro\n\t    formatGeocodeResults: function formatGeocodeResults(results) {\n\t        if (!_utils2.default.isArray(results) || results.length <= 0) {\n\t            return {\n\t                location: null,\n\t                address: null,\n\t                formattedAddress: '',\n\t                type: null, // locationType\n\t                placeId: ''\n\t            };\n\t        }\n\t\n\t        var i = void 0,\n\t            c = void 0,\n\t            o = {},\n\t            data = results[0],\n\t            comps = data.address_components;\n\t\n\t        for (i = 0; i < comps.length; i += 1) {\n\t            c = comps[i];\n\t            if (c.types && c.types.length > 0) {\n\t                o[c.types[0]] = c.long_name;\n\t                o[c.types[0] + '_s'] = c.short_name;\n\t            }\n\t        }\n\t\n\t        var isUS = o.country_s === 'US',\n\t            geometry = data.geometry;\n\t        return {\n\t            coords: geometry && geometry.location ? {\n\t                latitude: geometry.location.lat,\n\t                longitude: geometry.location.lng\n\t            } : null,\n\t            address: {\n\t                commonName: o.point_of_interest || o.premise || o.subpremise || o.colloquial_area || '',\n\t                streetNumber: o.street_number || '',\n\t                street: o.administrative_area_level_4 || o.administrative_area_level_3 || o.route || '',\n\t                route: o.route || '',\n\t                neighborhood: o.neighborhood || o.administrative_area_level_5 || o.administrative_area_level_4 || '',\n\t                town: o.sublocality || o.administrative_area_level_2 || '',\n\t                city: o.locality || o.administrative_area_level_1 || '',\n\t                region: o.administrative_area_level_2 || o.administrative_area_level_1 || '',\n\t                postalCode: o.postal_code || '',\n\t                state: isUS ? o.administrative_area_level_1 || '' : '',\n\t                stateCode: isUS ? o.administrative_area_level_1_s || '' : '',\n\t                country: o.country || '',\n\t                countryCode: o.country_s || ''\n\t            },\n\t            formattedAddress: data.formatted_address,\n\t            type: geometry.location_type || '',\n\t            placeId: data.place_id,\n\t            timestamp: _utils2.default.time()\n\t        };\n\t    },\n\t    geocode: function geocode(reverse, conf, options, callback) {\n\t        var opts = {};\n\t        if (_utils2.default.isString(options)) {\n\t            opts = {};\n\t            var prop = reverse ? 'placeId' : 'address';\n\t            opts[prop] = options;\n\t        } else if (_utils2.default.isPlainObject(options)) {\n\t            opts = options;\n\t        } else {\n\t            throw new _geo2.default(_geo2.default.Code.INVALID_PARAMETERS);\n\t        }\n\t\n\t        if (reverse) {\n\t            var coordsSet = _utils2.default.isNumber(options.latitude) && _utils2.default.isNumber(options.longitude);\n\t            if (!_utils2.default.isString(options.placeId) && !coordsSet) {\n\t                throw new _geo2.default(_geo2.default.Code.INVALID_PARAMETERS);\n\t            }\n\t        }\n\t\n\t        opts = _utils2.default.extend({\n\t            key: conf.google.key || '',\n\t            language: conf.language || 'en',\n\t            raw: false\n\t        }, opts);\n\t\n\t        var query = geoHelper.buildGeocodeParams(opts, reverse),\n\t            url = _utils2.default.setProtocol(_enums2.default.URL.GOOGLE_GEOCODE, conf.https),\n\t            xhrOpts = {\n\t            url: url + '?' + query\n\t        };\n\t\n\t        _fetch2.default.xhr(xhrOpts, function (err, xhr) {\n\t            if (err) return callback(_geo2.default.create(err), null);\n\t\n\t            var response = _utils2.default.safeJsonParse(xhr.responseText),\n\t                gErr = _geo2.default.fromResponse(response);\n\t\n\t            if (gErr) return callback(gErr, null);\n\t\n\t            response = options.raw ? response : geoHelper.formatGeocodeResults(response.results);\n\t            callback(null, response);\n\t        });\n\t    },\n\t\n\t\n\t    // See https://developers.google.com/maps/documentation/distance-matrix/intro\n\t    // Raw Result Example:\n\t    // {\n\t    //    \"destination_addresses\" : [ \"San Francisco, CA, USA\", \"Victoria, BC, Canada\" ],\n\t    //    \"origin_addresses\" : [ \"Vancouver, BC, Canada\", \"Seattle, WA, USA\" ],\n\t    //    \"rows\" : [\n\t    //       {\n\t    //          \"elements\" : [\n\t    //             {\n\t    //                \"distance\" : { \"text\" : \"1,704 km\", \"value\" : 1704324 },\n\t    //                \"duration\" : { \"text\" : \"3 days 19 hours\", \"value\" : 327061\n\t    //                },\n\t    //                \"status\" : \"OK\"\n\t    //             },\n\t    //             {\n\t    //                \"distance\" : { \"text\" : \"138 km\", \"value\" : 138295 },\n\t    //                \"duration\" : { \"text\" : \"6 hours 44 mins\", \"value\" : 24236 },\n\t    //                \"status\" : \"OK\"\n\t    //             }\n\t    //          ]\n\t    //       },\n\t    //       {\n\t    //          \"elements\" : [\n\t    //             {\n\t    //                \"distance\" : { \"text\" : \"1,452 km\", \"value\" : 1451623 },\n\t    //                \"duration\" : { \"text\" : \"3 days 4 hours\", \"value\" : 275062 },\n\t    //                \"status\" : \"OK\"\n\t    //             },\n\t    //             {\n\t    //                \"distance\" : { \"text\" : \"146 km\", \"value\" : 146496 },\n\t    //                \"duration\" : { \"text\" : \"2 hours 52 mins\", \"value\" : 10324 },\n\t    //                \"status\" : \"OK\"\n\t    //             }\n\t    //          ]\n\t    //       }\n\t    //    ],\n\t    //    \"status\" : \"OK\"\n\t    // }\n\t    // Formatted to:\n\t\n\t    formatDistanceResults: function formatDistanceResults(results) {\n\t        if (!_utils2.default.isPlainObject(results)) {\n\t            return null;\n\t        }\n\t\n\t        var arr = [],\n\t            origins = results.originAddresses,\n\t            dests = results.destinationAddresses,\n\t            rows = results.rows;\n\t\n\t        // [\n\t        //     {\n\t        //          from: 'Vancouver, BC, Canada',\n\t        //          to: 'San Francisco, CA, USA',\n\t        //          distance: { value: 1704107, text: \"1,704 km\" },\n\t        //          duration: { value: 327025, text: \"3 days 19 hours\" },\n\t        //          fare: { currency: \"USD\", value: 6, text: \"$6.00\" }\n\t        //     },\n\t        //     ...\n\t        // ]\n\t\n\t        var e = void 0;\n\t        origins.forEach(function (origin, oIndex) {\n\t            dests.forEach(function (dest, dIndex) {\n\t                e = rows[oIndex].elements[dIndex];\n\t                arr.push({\n\t                    from: origin,\n\t                    to: dest,\n\t                    distance: e.distance,\n\t                    duration: e.duration,\n\t                    fare: e.fare,\n\t                    timestamp: _utils2.default.time()\n\t                });\n\t            });\n\t        });\n\t\n\t        return arr;\n\t    }\n\t};\n\t\n\texports.default = geoHelper;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * This file only includes partial documentation about `geolocator` enumerations.\n\t * Note that these enumerations are mostly an aggregation of\n\t * {@link https://developers.google.com/maps/documentation/javascript|Google Maps API} constants.\n\t *\n\t * @private\n\t * @readonly\n\t */\n\tvar enums = Object.freeze({\n\t  /**\n\t   * Enumerates API endpoints used within Geolocator core.\n\t   *\n\t   * @enum {String}\n\t   * @readonly\n\t   * @private\n\t   */\n\t  URL: {\n\t    /**\n\t     *  Public IP retrieval (free) service.\n\t     *  @type {String}\n\t     *  @private\n\t     */\n\t    IP: '//api.ipify.org',\n\t    /**\n\t     *  Country SVG flags.\n\t     *  e.g. <url>/tr.svg for Turkey flag.\n\t     *  @type {String}\n\t     *  @private\n\t     */\n\t    FLAG: '//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/',\n\t    /**\n\t     * Google Maps API bootstrap endpoint that loads all of the main\n\t     * Javascript objects and symbols for use in the Maps API.\n\t     * Some Maps API features are also available in self-contained\n\t     * libraries which are not loaded unless you specifically request them.\n\t     * See {@link https://developers.google.com/maps/documentation/javascript/libraries|details}.\n\t     * @type {String}\n\t     * @private\n\t     */\n\t    GOOGLE_MAPS_API: '//maps.googleapis.com/maps/api/js',\n\t    /**\n\t     * Google Geolocation API endpoint.\n\t     * @type {String}\n\t     * @private\n\t     */\n\t    GOOGLE_GEOLOCATION: '//www.googleapis.com/geolocation/v1/geolocate',\n\t    /**\n\t     * Google Geocode API endpoint.\n\t     * @type {String}\n\t     * @private\n\t     */\n\t    GOOGLE_GEOCODE: '//maps.googleapis.com/maps/api/geocode/json',\n\t    /**\n\t     * Google TimeZone API endpoint.\n\t     * @type {String}\n\t     * @private\n\t     */\n\t    GOOGLE_TIMEZONE: '//maps.googleapis.com/maps/api/timezone/json',\n\t    /**\n\t     * Google Distance Matrix API endpoint.\n\t     * @type {String}\n\t     * @private\n\t     */\n\t    GOOGLE_DISTANCE_MATRIX: '//maps.googleapis.com/maps/api/distancematrix/json'\n\t  },\n\t  /**\n\t   * Enumerates Google map types.\n\t   * @memberof! geolocator\n\t   *\n\t   * @enum {String}\n\t   * @readonly\n\t   */\n\t  MapTypeId: {\n\t    /**\n\t     * Map type that displays a transparent layer of major streets on\n\t     * satellite images.\n\t     * @type {String}\n\t     */\n\t    HYBRID: 'hybrid',\n\t    /**\n\t     * Map type that displays a normal street map.\n\t     * @type {String}\n\t     */\n\t    ROADMAP: 'roadmap',\n\t    /**\n\t     * Map type that displays satellite images.\n\t     * @type {String}\n\t     */\n\t    SATELLITE: 'satellite',\n\t    /**\n\t     * Map type displays maps with physical features such as terrain and\n\t     * vegetation.\n\t     * @type {String}\n\t     */\n\t    TERRAIN: 'terrain'\n\t  },\n\t  /**\n\t   * Enumerates Google location types.\n\t   * @memberof! geolocator\n\t   *\n\t   * @enum {String}\n\t   * @readonly\n\t   */\n\t  LocationType: {\n\t    /**\n\t     * Indicates that the returned result is a precise geocode for which\n\t     * we have location information accurate down to street address\n\t     * precision.\n\t     * @type {String}\n\t     */\n\t    ROOFTOP: 'ROOFTOP',\n\t    /**\n\t     * Indicates that the returned result reflects an approximation\n\t     * (usually on a road) interpolated between two precise points (such as\n\t     * intersections). Interpolated results are generally returned when\n\t     * rooftop geocodes are unavailable for a street address.\n\t     * @type {String}\n\t     */\n\t    RANGE_INTERPOLATED: 'RANGE_INTERPOLATED',\n\t    /**\n\t     * Indicates that the returned result is the geometric center of a\n\t     * result such as a polyline (for example, a street) or polygon\n\t     * (region).\n\t     * @type {String}\n\t     */\n\t    GEOMETRIC_CENTER: 'GEOMETRIC_CENTER',\n\t    /**\n\t     * Indicates that the returned result is approximate.\n\t     * @type {String}\n\t     */\n\t    APPROXIMATE: 'APPROXIMATE'\n\t  },\n\t  /**\n\t   * Enumerates Google travel modes.\n\t   * @memberof! geolocator\n\t   *\n\t   * @enum {String}\n\t   * @readonly\n\t   */\n\t  TravelMode: {\n\t    /**\n\t     * Indicates distance calculation using the road network.\n\t     * @type {String}\n\t     */\n\t    DRIVING: 'DRIVING',\n\t    /**\n\t     * Requests distance calculation for walking via pedestrian paths &\n\t     * sidewalks (where available).\n\t     * @type {String}\n\t     */\n\t    WALKING: 'WALKING',\n\t    /**\n\t     * Requests distance calculation for bicycling via bicycle paths &\n\t     * preferred streets (where available).\n\t     * @type {String}\n\t     */\n\t    BICYCLING: 'BICYCLING',\n\t    /**\n\t     * Requests distance calculation via public transit routes (where\n\t     * available). This value may only be specified if the request includes\n\t     * an API key or a Google Maps APIs Premium Plan client ID. If you set\n\t     * the mode to transit you can optionally specify either a\n\t     * `departureTime` or an `arrivalTime`. If neither time is specified,\n\t     * the `departureTime` defaults to now (that is, the departure time defaults\n\t     * to the current time). You can also optionally include a `transitMode`\n\t     * and/or a `transitRoutingPreference`.\n\t     * @type {String}\n\t     */\n\t    TRANSIT: 'TRANSIT'\n\t  },\n\t  // /**\n\t  //  * Enumerates Google route restrictions.\n\t  //  * @memberof! geolocator\n\t  //  *\n\t  //  * @enum {String}\n\t  //  * @readonly\n\t  //  */\n\t  // RouteRestriction: {\n\t  //     TOLLS: 'tolls',\n\t  //     HIGHWAYS: 'highways',\n\t  //     FERRIES: 'ferries',\n\t  //     INDOOR: 'indoor'\n\t  // },\n\t  /**\n\t   * Enumerates Google unit systems.\n\t   * @memberof! geolocator\n\t   *\n\t   * @enum {Number}\n\t   * @readonly\n\t   */\n\t  UnitSystem: {\n\t    /**\n\t     * Distances in kilometers and meters.\n\t     * @type {Number}\n\t     */\n\t    METRIC: 0,\n\t    /**\n\t     * Distances defined in miles and feet.\n\t     * @type {Number}\n\t     */\n\t    IMPERIAL: 1\n\t  },\n\t  /**\n\t   * Enumerates mobile radio types.\n\t   * @memberof! geolocator\n\t   *\n\t   * @enum {String}\n\t   * @readonly\n\t   */\n\t  RadioType: {\n\t    /**\n\t     * LTE (Long-Term Evolution) mobile radio type.\n\t     * @type {String}\n\t     */\n\t    LTE: 'lte',\n\t    /**\n\t     * GSM (Global System for Mobile Communications) mobile radio type.\n\t     * @type {String}\n\t     */\n\t    GSM: 'gsm',\n\t    /**\n\t     * CDMA (Code division multiple access) mobile radio access technology.\n\t     * @type {String}\n\t     */\n\t    CDMA: 'cdma',\n\t    /**\n\t     * Wideband CDMA mobile radio access technology.\n\t     * @type {String}\n\t     */\n\t    WCDMA: 'wcdma'\n\t  },\n\t  /**\n\t   * Enumerates formulas/algorithms for calculating the distance between two\n\t   * lat/lng points.\n\t   * @memberof! geolocator\n\t   *\n\t   * @readonly\n\t   * @enum {String}\n\t   *\n\t   * @todo {@link https://en.wikipedia.org/wiki/Vincenty%27s_formulae|Vincenty's Formula}\n\t   */\n\t  DistanceFormula: {\n\t    /**\n\t     * Haversine formula for calculating the distance between two lat/lng points\n\t     * by relating the sides and angles of spherical triangles.\n\t     * @see {@link http://en.wikipedia.org/wiki/Haversine_formula|Haversine_formula}.\n\t     * @type {String}\n\t     */\n\t    HAVERSINE: 'haversine',\n\t    /**\n\t     * Formula based on the Pythagoras Theorem for calculating the\n\t     * distance between two lat/lng points on a Equirectangular projection\n\t     * to account for curvature of the longitude lines.\n\t     * @see {@link https://en.wikipedia.org/wiki/Pythagorean_theorem|Pythagorean_theorem}\n\t     * @type {String}\n\t     */\n\t    PYTHAGOREAN: 'pythagorean'\n\t  }\n\t});\n\t\n\texports.default = enums;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Geolocator Error class that provides a common type of error object for the\n\t * various APIs implemented in Geolocator. All callbacks of Geolocator will\n\t * include an instance of this object as the first argument; if the\n\t * corresponding operation fails. Also all thrown errors will be an instance of\n\t * this object.\n\t *\n\t * This object can be publicly accessed via `geolocator.Error`.\n\t *\n\t * @extends Error\n\t */\n\t\n\tvar GeoError = function () {\n\t    // extends Error (doesn't work with transpilers)\n\t\n\t    /**\n\t     * Costructs a new instance of `GeoError`.\n\t     *\n\t     * @param {String} [code=\"UNKNOWN_ERROR\"]\n\t     *        Any valid Geolocator Error code.\n\t     *        See {@link #GeoError.Code|`GeoError.Code` enumeration} for\n\t     *        possible values.\n\t     * @param {String} [message]\n\t     *        Error message. If omitted, this will be set to `code`.\n\t     *\n\t     * @returns {GeoError}\n\t     *\n\t     * @example\n\t     * var GeoError = geolocator.Error,\n\t     *     error = new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n\t     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n\t     * console.log(error instanceof GeoError); // true\n\t     */\n\t\n\t    function GeoError() {\n\t        var code = arguments.length <= 0 || arguments[0] === undefined ? GeoError.Code.UNKNOWN_ERROR : arguments[0];\n\t        var message = arguments[1];\n\t\n\t        _classCallCheck(this, GeoError);\n\t\n\t        message = message || String(code);\n\t\n\t        /**\n\t         *  Gets the name of the Error object.\n\t         *  This always returns `\"GeoError\"`.\n\t         *  @name GeoError#name\n\t         *  @type {String}\n\t         */\n\t        Object.defineProperty(this, 'name', {\n\t            enumerable: false,\n\t            writable: false,\n\t            value: 'GeoError' // this.constructor.name\n\t        });\n\t\n\t        /**\n\t         *  Gets the error code set for this instance.\n\t         *  This will return one of\n\t         *  {@link #GeoError.Code|`GeoError.Code` enumeration}.\n\t         *  @name GeoError#code\n\t         *  @type {String}\n\t         */\n\t        Object.defineProperty(this, 'code', {\n\t            enumerable: false,\n\t            writable: true,\n\t            value: code\n\t        });\n\t\n\t        /**\n\t         *  Gets the error message set for this instance.\n\t         *  If no message is set, this will return the error code value.\n\t         *  @name GeoError#message\n\t         *  @type {String}\n\t         */\n\t        Object.defineProperty(this, 'message', {\n\t            enumerable: false,\n\t            writable: true,\n\t            value: message\n\t        });\n\t\n\t        if (Error.hasOwnProperty('captureStackTrace')) {\n\t            // V8\n\t            Error.captureStackTrace(this, this.constructor);\n\t        } else {\n\t            /**\n\t             *  Gets the error stack for this instance.\n\t             *  @name GeoError#stack\n\t             *  @type {String}\n\t             */\n\t            Object.defineProperty(this, 'stack', {\n\t                enumerable: false,\n\t                writable: false,\n\t                value: new Error(message).stack\n\t            });\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Creates a new instance of `GeoError` from the given value.\n\t     *\n\t     * @param {*} [err]\n\t     *        Value to be transformed. This is used to determine the proper\n\t     *        error code for the created instance. If an `Error` or `Object` is\n\t     *        passed, its `message` property is checked if it matches any of the\n\t     *        valid error codes. If omitted or no match is found, error code\n\t     *        `GeoError.Code.UNKNOWN_ERROR` will be used as default.\n\t     *\n\t     * @returns {GeoError}\n\t     *\n\t     * @example\n\t     * var GeoError = geolocator.Error,\n\t     * \t   error = GeoError.create();\n\t     * console.log(error.code); // \"UNKNOWN_ERROR\"\n\t     * error = GeoError.create(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n\t     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n\t     */\n\t\n\t\n\t    _createClass(GeoError, null, [{\n\t        key: 'create',\n\t        value: function create(err) {\n\t            if (err instanceof GeoError) {\n\t                return err;\n\t            }\n\t\n\t            if (_utils2.default.isPositionError(err) && err.code) {\n\t                switch (err.code) {\n\t                    case 1:\n\t                        return new GeoError(GeoError.Code.PERMISSION_DENIED, err.message);\n\t                    case 2:\n\t                        return new GeoError(GeoError.Code.POSITION_UNAVAILABLE, err.message);\n\t                    case 3:\n\t                        return new GeoError(GeoError.Code.TIMEOUT, err.message);\n\t                    default:\n\t                        return new GeoError(GeoError.Code.UNKNOWN_ERROR, err.message || '');\n\t                }\n\t            }\n\t\n\t            var code = void 0,\n\t                msg = void 0;\n\t            if (typeof err === 'string') {\n\t                code = msg = err;\n\t            } else if ((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object') {\n\t                code = err.code || err.message;\n\t                msg = err.message || err.code;\n\t            }\n\t            if (code && GeoError.isValidErrorCode(code)) {\n\t                return new GeoError(code, msg);\n\t            }\n\t\n\t            return new GeoError(GeoError.Code.UNKNOWN_ERROR, msg);\n\t        }\n\t\n\t        /**\n\t         * Creates a new instance of `GeoError` from the given response object.\n\t         * Since Geolocator implements various Google APIs, we might receive\n\t         * responses if different structures. For example, some APIs return a\n\t         * response object with a `status:String` property (such as the TimeZone\n\t         * API) and some return responses with an `error:Object` property. This\n\t         * method will determine the correct reason or message and return a\n\t         * consistent error object.\n\t         *\n\t         * @param {Object|String} response\n\t         *        Response (Object) or status (String) to be transformed.\n\t         * @param {String} [message=null]\n\t         *        Error message.\n\t         *\n\t         * @returns {GeoError}\n\t         *          `GeoError` instance if response contains an error. Otherwise,\n\t         *          returns `null`.\n\t         *\n\t         * @example\n\t         * var error = geolocator.Error.fromResponse(googleResponse);\n\t         * console.log(error.code); // \"GOOGLE_KEY_INVALID\"\n\t         */\n\t\n\t    }, {\n\t        key: 'fromResponse',\n\t        value: function fromResponse(response) {\n\t            var message = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t            // example Google Geolocation API response:\n\t            // https://developers.google.com/maps/documentation/geolocation/intro#errors\n\t            // {\n\t            //      \"error\": {\n\t            //          \"errors\": [\n\t            //              {\n\t            //                  \"domain\": \"global\",\n\t            //                  \"reason\": \"parseError\",\n\t            //                  \"message\": \"Parse Error\",\n\t            //              }\n\t            //          ],\n\t            //      \"code\": 400,\n\t            //      \"message\": \"Parse Error\"\n\t            //      }\n\t            // }\n\t            // example Google TimeZone API response:\n\t            // {\n\t            //     \"status\": \"REQUEST_DENIED\"\n\t            // }\n\t\n\t            if (!response) return new GeoError(GeoError.Code.INVALID_RESPONSE);\n\t\n\t            var errCode = void 0;\n\t\n\t            if (_utils2.default.isString(response)) {\n\t                errCode = errorCodeFromStatus(response);\n\t                if (errCode) return new GeoError(errCode, message || response);\n\t            }\n\t\n\t            if (!_utils2.default.isObject(response)) return null;\n\t\n\t            var errMsg = response.error_message || response.errorMessage || response.error && response.error.message || '' || '';\n\t\n\t            if (response.status) {\n\t                errCode = errorCodeFromStatus(response.status);\n\t                if (errCode) return new GeoError(errCode, errMsg || message || response.status);\n\t            }\n\t\n\t            if (response.error) {\n\t                var reason = response.reason || response.error.reason;\n\t                if (!reason) {\n\t                    var errors = response.error.errors;\n\t                    if (_utils2.default.isArray(errors) && errors.length > 0) {\n\t                        reason = errors[0].reason; // get the first reason only\n\t                        errMsg = errMsg || errors[0].message; // update errMsg\n\t                    }\n\t                }\n\t                errCode = errorCodeFromReason(reason) || GeoError.Code.UNKNOWN_ERROR;\n\t                return new GeoError(errCode, errMsg || reason || message);\n\t            }\n\t\n\t            if (errMsg) {\n\t                errCode = errorCodeFromStatus(errMsg) || GeoError.Code.UNKNOWN_ERROR;\n\t                return new GeoError(errCode, errMsg || message);\n\t            }\n\t\n\t            return null;\n\t        }\n\t\n\t        /**\n\t         *  Checks whether the given value is an instance of `GeoError`.\n\t         *\n\t         *  @param {*} err - Object to be checked.\n\t         *\n\t         *  @returns {Boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isGeoError',\n\t        value: function isGeoError(err) {\n\t            return err instanceof GeoError;\n\t        }\n\t\n\t        /**\n\t         *  Checks whether the given value is a valid Geolocator Error code.\n\t         *\n\t         *  @param {String} errorCode - Error code to be checked.\n\t         *\n\t         *  @returns {Boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isValidErrorCode',\n\t        value: function isValidErrorCode(errorCode) {\n\t            var prop = void 0;\n\t            for (prop in GeoError.Code) {\n\t                if (GeoError.Code.hasOwnProperty(prop) && errorCode === GeoError.Code[prop]) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return GeoError;\n\t}();\n\t\n\t/**\n\t *  Gets the string representation of the error instance.\n\t *\n\t *  @returns {String}\n\t */\n\t\n\t\n\tGeoError.prototype.toString = function () {\n\t    var msg = this.code !== this.message ? ' (' + this.message + ')' : '';\n\t    return this.name + ': ' + this.code + msg;\n\t};\n\t\n\t// `class x extends Error` doesn't work when using an ES6 transpiler, such as\n\t// Babel, since subclasses must extend a class. With Babel 6, we need\n\t// transform-builtin-extend plugin for this to work. So we're extending from\n\t// Error the old way. Now, `err instanceof Error` also returns `true`.\n\tif (typeof Object.setPrototypeOf === 'function') {\n\t    Object.setPrototypeOf(GeoError.prototype, Error.prototype);\n\t} else {\n\t    GeoError.prototype = Object.create(Error.prototype);\n\t}\n\t\n\t// ---------------------------\n\t// ERROR CODES\n\t// ---------------------------\n\t\n\t/**\n\t *  Enumerates Geolocator error codes.\n\t *  This enumeration combines Google API status (error) codes, HTML5 Geolocation\n\t *  position error codes and other Geolocator-specific error codes.\n\t *  @enum {String}\n\t */\n\tGeoError.Code = {\n\t    /**\n\t     *  Indicates that HTML5 Geolocation API is not supported by the browser.\n\t     *  @type {String}\n\t     */\n\t    GEOLOCATION_NOT_SUPPORTED: 'GEOLOCATION_NOT_SUPPORTED',\n\t    /**\n\t     *  Indicates that Geolocation-IP source is not set or invalid.\n\t     *  @type {String}\n\t     */\n\t    INVALID_GEO_IP_SOURCE: 'INVALID_GEO_IP_SOURCE',\n\t    /**\n\t     *  The acquisition of the geolocation information failed because the\n\t     *  page didn't have the permission to do it.\n\t     *  @type {String}\n\t     */\n\t    PERMISSION_DENIED: 'PERMISSION_DENIED',\n\t    /**\n\t     *  The acquisition of the geolocation failed because at least one\n\t     *  internal source of position returned an internal error.\n\t     *  @type {String}\n\t     */\n\t    POSITION_UNAVAILABLE: 'POSITION_UNAVAILABLE',\n\t    /**\n\t     *  The time allowed to acquire the geolocation, defined by\n\t     *  PositionOptions.timeout information was reached before\n\t     *  the information was obtained.\n\t     *  @type {String}\n\t     */\n\t    TIMEOUT: 'TIMEOUT',\n\t    /**\n\t     * Indicates that the request had one or more invalid parameters.\n\t     * @type {String}\n\t     */\n\t    INVALID_PARAMETERS: 'INVALID_PARAMETERS',\n\t    /**\n\t     * Indicates that the service returned invalid response.\n\t     * @type {String}\n\t     */\n\t    INVALID_RESPONSE: 'INVALID_RESPONSE',\n\t    /**\n\t     * Generally indicates that the query (address, components or latlng)\n\t     * is missing.\n\t     * @type {String}\n\t     */\n\t    INVALID_REQUEST: 'INVALID_REQUEST',\n\t    /**\n\t     * Indicates that the request was denied by the service.\n\t     * This will generally occur because of a missing API key or because the request\n\t     * is sent over HTTP instead of HTTPS.\n\t     * @type {String}\n\t     */\n\t    REQUEST_DENIED: 'REQUEST_DENIED',\n\t    /**\n\t     * Indicates that the request has failed.\n\t     * This will generally occur because of an XHR error.\n\t     * @type {String}\n\t     */\n\t    REQUEST_FAILED: 'REQUEST_FAILED',\n\t    /**\n\t     * Indicates that Google API could not be loaded.\n\t     * @type {String}\n\t     */\n\t    GOOGLE_API_FAILED: 'GOOGLE_API_FAILED',\n\t    /**\n\t     * Indicates that you are over your Google API quota.\n\t     * @type {String}\n\t     */\n\t    OVER_QUERY_LIMIT: 'OVER_QUERY_LIMIT',\n\t    /**\n\t     * Indicates that you've exceeded the requests per second per user limit that\n\t     * you configured in the Google Developers Console. This limit should be\n\t     * configured to prevent a single or small group of users from exhausting your\n\t     * daily quota, while still allowing reasonable access to all users.\n\t     * @type {String}\n\t     */\n\t    USER_RATE_LIMIT_EXCEEDED: 'USER_RATE_LIMIT_EXCEEDED',\n\t    /**\n\t     * Indicates that you've exceeded your daily limit for Google API(s).\n\t     * @type {String}\n\t     */\n\t    DAILY_LIMIT_EXCEEDED: 'DAILY_LIMIT_EXCEEDED',\n\t    /**\n\t     * Indicates that your Google API key is not valid. Please ensure that you've\n\t     * included the entire key, and that you've either purchased the API or have\n\t     * enabled billing and activated the API to obtain the free quota.\n\t     * @type {String}\n\t     */\n\t    GOOGLE_KEY_INVALID: 'GOOGLE_KEY_INVALID',\n\t    /**\n\t     * Indicates that maximum number of elements limit is exceeded. For\n\t     * example, for the Distance Matrix API; occurs when the product of\n\t     * origins and destinations exceeds the per-query limit.\n\t     * @type {String}\n\t     */\n\t    MAX_ELEMENTS_EXCEEDED: 'MAX_ELEMENTS_EXCEEDED',\n\t    /**\n\t     * Indicates that the request contained more than 25 origins,\n\t     * or more than 25 destinations.\n\t     * @type {String}\n\t     */\n\t    MAX_DIMENSIONS_EXCEEDED: 'MAX_DIMENSIONS_EXCEEDED',\n\t    /**\n\t     * Indicates that the request contained more than allowed waypoints.\n\t     * @type {String}\n\t     */\n\t    MAX_WAYPOINTS_EXCEEDED: 'MAX_WAYPOINTS_EXCEEDED',\n\t    /**\n\t     * Indicates that the request body is not valid JSON.\n\t     * @type {String}\n\t     */\n\t    PARSE_ERROR: 'PARSE_ERROR',\n\t    /**\n\t     * Indicates that the requested resource could not be found.\n\t     * Note that this also covers `ZERO_RESULTS`.\n\t     * @type {String}\n\t     */\n\t    NOT_FOUND: 'NOT_FOUND',\n\t    /**\n\t     * Indicates that an internal error (such as XHR cross-domain, etc) has occured.\n\t     * @type {String}\n\t     */\n\t    INTERNAL_ERROR: 'INTERNAL_ERROR',\n\t    /**\n\t     * Indicates that an unknown error has occured.\n\t     * @type {String}\n\t     */\n\t    UNKNOWN_ERROR: 'UNKNOWN_ERROR'\n\t};\n\t\n\t// ---------------------------\n\t// HELPER METHODS\n\t// ---------------------------\n\t\n\t/**\n\t *  @private\n\t */\n\tfunction errorCodeFromStatus(status) {\n\t    if (!status) return GeoError.Code.INVALID_RESPONSE;\n\t    if (status === 'OK') return null;\n\t    if (status === 'ZERO_RESULTS') return GeoError.Code.NOT_FOUND;\n\t    if (GeoError.Code.hasOwnProperty(status)) return status;\n\t    return null;\n\t}\n\t\n\t/**\n\t *  Gets `GeoError.Code` from the given response error reason.\n\t *  @private\n\t *\n\t *  @param {String} reason\n\t *         Google response error reason.\n\t *\n\t *  @returns {String}\n\t */\n\tfunction errorCodeFromReason(reason) {\n\t    switch (reason) {\n\t        case 'invalid':\n\t            return GeoError.Code.INVALID_REQUEST;\n\t        case 'dailyLimitExceeded':\n\t            return GeoError.Code.DAILY_LIMIT_EXCEEDED;\n\t        case 'keyInvalid':\n\t            return GeoError.Code.GOOGLE_KEY_INVALID;\n\t        case 'userRateLimitExceeded':\n\t            return GeoError.Code.USER_RATE_LIMIT_EXCEEDED;\n\t        case 'notFound':\n\t            return GeoError.Code.NOT_FOUND;\n\t        case 'parseError':\n\t            return GeoError.Code.PARSE_ERROR;\n\t        default:\n\t            return null;\n\t    }\n\t}\n\t\n\t// ---------------------------\n\t// EXPORT\n\t// ---------------------------\n\t\n\texports.default = GeoError;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-nested-ternary:0 */\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GeoWatcher = function () {\n\t    function GeoWatcher(onChange, onError) {\n\t        var _this = this;\n\t\n\t        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t        _classCallCheck(this, GeoWatcher);\n\t\n\t        this.isCleared = false;\n\t        this.cycle = 0;\n\t        this._timer = null;\n\t        this.id = navigator.geolocation.watchPosition(function (pos) {\n\t            _this.cycle++;\n\t            if (_utils2.default.isFunction(onChange)) onChange(pos);\n\t        }, function (err) {\n\t            _this.cycle++;\n\t            if (_utils2.default.isFunction(onError)) onError(err);\n\t            if (options.clearOnError) {\n\t                _this.clear();\n\t            }\n\t        }, options);\n\t    }\n\t\n\t    _createClass(GeoWatcher, [{\n\t        key: '_clear',\n\t        value: function _clear() {\n\t            navigator.geolocation.clearWatch(this.id);\n\t            this.isCleared = true;\n\t            this._timer = null;\n\t        }\n\t    }, {\n\t        key: 'clear',\n\t        value: function clear(delay, callback) {\n\t            var _this2 = this;\n\t\n\t            var d = _utils2.default.isNumber(delay) ? delay : 0,\n\t                cb = _utils2.default.isFunction(callback) ? callback : _utils2.default.isFunction(delay) ? delay : null;\n\t            // clear any previous timeout\n\t            if (this._timer) {\n\t                clearTimeout(this._timer);\n\t                this._timer = null;\n\t            }\n\t            // check if watcher is not cleared\n\t            if (!this.isCleared) {\n\t                if (d === 0) {\n\t                    this._clear();\n\t                    if (cb) cb();\n\t                    return;\n\t                }\n\t                this._timer = setTimeout(function () {\n\t                    _this2._clear();\n\t                    if (cb) cb();\n\t                }, d);\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return GeoWatcher;\n\t}();\n\t\n\t// ---------------------------\n\t// EXPORT\n\t// ---------------------------\n\t\n\texports.default = GeoWatcher;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** geolocator.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5ca6fc4ba6e64a61be9c\n **/","import geolocator from './core/geolocator';\n// export default geolocator;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = geolocator;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import utils from '../lib/utils';\nimport fetch from '../lib/fetch';\nimport geoHelper from './geo.helper';\nimport GeoError from './geo.error';\nimport GeoWatcher from './geo.watcher';\nimport enums from './enums';\n\n/**\n * Radius of earth in kilometers.\n * @private\n * @type {Number}\n */\nconst EARTH_RADIUS_KM = 6371;\n\n/**\n * Radius of earth in miles.\n * @private\n * @type {Number}\n */\nconst EARTH_RADIUS_MI = 3959;\n\n/**\n * Storage for Geolocator default configuration.\n *\n * @readonly\n * @private\n */\nconst defaultConfig = {\n    language: 'en',\n    https: true,\n    google: {\n        version: '3', // latest 3.x\n        key: ''\n    }\n};\n\n/**\n * Geolocator library that provides methods for getting geo-location information,\n * geocoding, address look-ups, distance & durations, timezone information and more...\n * This library makes use of HTML5 position feautures, implements Google APIs\n * and other services.\n *\n * <b>Important Notes:</b>\n *\n * Although some calls might work without a key, it is generally required by\n * most {@link https://developers.google.com/maps/faq#using-google-maps-apis|Goolge APIs}\n * (such as Time Zone API). To get a free (or premium) key,\n * {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n * After getting a key, you can enable multiple APIs for it. Make sure you\n * {@link https://console.developers.google.com|enable}\n * all the APIs supported by Geolocator.\n *\n * Note that browser API keys cannot have referer restrictions when used\n * with some Google APIs.\n *\n * Make sure your doctype is HTML5 and you're calling Geolocation APIs from an\n * HTTPS page. Geolocation API is removed from unsecured origins in Chrome 50.\n * Other browsers are expected to follow.\n *\n * @license MIT\n * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nclass geolocator {\n\n    // ---------------------------\n    // PROPERTIES\n    // ---------------------------\n\n    /**\n     * Geolocator Error class that provides a common type of error object for\n     * the various APIs implemented in Geolocator. All callbacks of Geolocator\n     * will include an instance of this object as the first argument; if the\n     * corresponding operation fails. Also all thrown errors will be an instance\n     * of this object.\n     *\n     * This object also enumerates\n     * {@link ?api=geolocator-error#GeoError.Code|Geolocator Error codes}.\n     *\n     * @see {@link ?api=geolocator-error|`GeoError` documentation}\n     * @type {GeoError}\n     * @readonly\n     */\n    static get Error() {\n        return GeoError;\n    }\n\n    /**\n     * Documented in separately in enums.js\n     * @private\n     */\n    static get MapTypeId() {\n        return enums.MapTypeId;\n    }\n\n    /**\n     * Documented in separately in enums.js\n     * @private\n     */\n    static get LocationType() {\n        return enums.LocationType;\n    }\n\n    /**\n     * Documented in separately in enums.js\n     * @private\n     */\n    static get TravelMode() {\n        return enums.TravelMode;\n    }\n\n    /**\n     * Documented in separately in enums.js\n     * @private\n     */\n    static get UnitSystem() {\n        return enums.UnitSystem;\n    }\n\n    /**\n     * Documented in separately in enums.js\n     * @private\n     */\n    static get RadioType() {\n        return enums.RadioType;\n    }\n\n    /**\n     * Documented in separately in enums.js\n     * @private\n     */\n    static get DistanceFormula() {\n        return enums.DistanceFormula;\n    }\n\n    // ---------------------------\n    // STATIC METHODS\n    // ---------------------------\n\n    /**\n     * Sets or gets the geolocator configuration object.\n     * Make sure you configure Geolocator before calling other methods that\n     * require a Google API key.\n     *\n     * @param {Object} [options]\n     *        Configuration object. If omitted, this method returns the current\n     *        configuration.\n     *     @param {String} [options.language=\"en\"]\n     *            Language to be used for API requests that supports language\n     *            configurations. This is generally used for Google APIs.\n     *            See {@link https://developers.google.com/maps/faq#languagesupport|supported languages}.\n     *     @param {Boolean} [options.https=true]\n     *            As Google recommends; using HTTPS encryption makes your site\n     *            more secure, and more resistant to snooping or tampering.\n     *            If set to `true`, the API calls are made over HTTPS, at all\n     *            times. Setting to `false` will switch to HTTP (even if the\n     *            page is on HTTPS). And if set to `null`, current protocol will\n     *            be used. Note that some APIs might not work with HTTP such as\n     *            Google Maps TimeZone API.\n     *     @param {Object} [options.google]\n     *            Google specific options.\n     *         @param {String} [options.google.version=\"3\"]\n     *                Google Maps API version to be used (with\n     *                `geolocator.createMap()`) method. The default version\n     *                value is tested and works with Geolocator. You can set a\n     *                greater value or the latest version number and it should\n     *                work; but it's not guaranteed. Find out the\n     *                {@link https://developers.google.com/maps/documentation/javascript/versions|latest version here}.\n     *         @param {String} [options.google.key=\"\"]\n     *                API key to be used with Google API calls. Although some\n     *                calls might work without a key, it is generally required\n     *                by most Goolge APIs. To get a free (or premium) key,\n     *                {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n     *\n     * @returns {Object} - Returns the current or updated configuration object.\n     *\n     * @example\n     * geolocator.config({\n     *     language: \"en\",\n     *     google: {\n     *     \t   version: \"3\",\n     *         key: \"YOUR-GOOGLE-API-KEY\"\n     *     }\n     * });\n     */\n    static config(options) {\n        if (options) {\n            geolocator._.config = utils.extend(defaultConfig, options);\n        }\n        return geolocator._.config;\n    }\n\n    /**\n     * Creates a Google Map within the given element.\n     * @see {@link https://developers.google.com/maps/documentation/javascript/reference|Google Maps JavaScript API}\n     * @see {@link https://developers.google.com/maps/documentation/javascript/usage|Usage Limits}\n     *\n     * @param {Object|String|HTMLElement|Map} options\n     *        Either map options object with the following properties or; the ID\n     *        of a DOM element, or element itself which the map will be\n     *        created within; or a previously created `google.maps.Map` instance.\n     *        If a map instance is set, this only will apply the options without\n     *        re-creating it.\n     *     @param {String|HTMLElement|Map} options.element\n     *            Either the ID of a DOM element or the element itself;\n     *            which the map will be created within; or a previously created\n     *            `google.maps.Map` instance. If a map instance is set, this\n     *            only will apply the options without re-creating it.\n     *     @param {Object} options.center\n     *            Center coordinates for the map to be created.\n     *         @param {Number} options.center.latitude\n     *                Latitude of the center point coordinates.\n     *         @param {Number} options.center.longitude\n     *                Longitude of the center point coordinates.\n     *     @param {String} [options.mapTypeId=\"roadmap\"]\n     *            Type of the map to be created.\n     *            See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n     *            for possible values.\n     *     @param {String} [options.title]\n     *            Title text to be displayed within an `InfoWindow`, when the\n     *            marker is clicked. This only take effect if `marker` is\n     *            enabled.\n     *     @param {Boolean} [options.marker=true]\n     *            Whether to place a marker at the given coordinates.\n     *            If `title` is set, an `InfoWindow` will be opened when the\n     *            marker is clicked.\n     *     @param {Number} [options.zoom=9]\n     *            Zoom level to be set for the map.\n     *\n     * @param {Function} callback\n     *        Callback function to be executed when the map is created.\n     *        This takes 2 arguments: `function (err, map) { ... }`.\n     *        See {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var options = {\n     *     element: \"my-map\",\n     * \t   center: {\n     * \t       latitude: 48.8534100,\n     *         longitude: 2.3488000\n     * \t   },\n     * \t   marker: true,\n     * \t   title: \"Paris, France\",\n     * \t   zoom: 12\n     * };\n     * geolocator.createMap(options, function (err, map) {\n     * \t   if (map && map.infoWindow) {\n     * \t\t   map.infoWindow.open(map.instance, map.marker);\n     * \t   }\n     * });\n     */\n    static createMap(options, callback) {\n        // if options is not a plain object, consider element ID, `HTMLElement`,\n        // `jQuery` instance or `google.maps.Map` instance.\n        if (!utils.isPlainObject(options)) {\n            options = { element: options };\n        }\n\n        options = utils.extend({\n            element: null,\n            mapTypeId: enums.MapTypeId.ROADMAP,\n            title: undefined,\n            marker: true,\n            zoom: 9\n        }, options);\n\n        let e = options.element,\n            elem;\n        if (utils.isString(e)) {\n            elem = document.getElementById(e);\n        } else if (utils.isJQueryObject(e)) {\n            elem = e[0];\n        } else if (geolocator.isGoogleLoaded() && e instanceof google.maps.Map) {\n            elem = e.getDiv();\n        }\n\n        if (!utils.isElement(elem) && !utils.isNode(elem)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS,\n                'A valid DOM element or element ID is required to create a map.');\n        }\n\n        if (!utils.isPlainObject(options.center)\n                || !utils.isNumber(options.center.latitude)\n                || !utils.isNumber(options.center.longitude)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS,\n                'Center coordinates are required to create a map.');\n        }\n\n        options.element = elem;\n\n        let key = geolocator._.config.google.key;\n        geolocator.ensureGoogleLoaded(key, err => {\n            if (err) {\n                throw new GeoError(GeoError.Code.GOOGLE_API_FAILED, String(err.message || err));\n            }\n\n            let mapData = configCreateMap(options);\n            callback(null, mapData);\n        });\n    }\n\n    /**\n     * Locates the user's location via HTML5 geolocation. This may\n     * require/prompt for user's permission. If the permission is granted we'll\n     * get the most accurate location information. Otherwise, we'll fallback to\n     * locating via user's IP (if enabled).\n     *\n     * For better accuracy, Geolocator implements a different approach than the\n     * `getCurrentPosition` API; which generally triggers before the device's\n     * GPS hardware can provide anything accurate. Thanks to\n     * {@link https://github.com/gwilson/getAccurateCurrentPosition#background|Greg Wilson}\n     * for the idea.\n     *\n     * Also note that HTML5 Geolocation feature no more allows insecure origins.\n     * See {@link https://goo.gl/rStTGz|this} for more details.\n     * This means if you don't call this method from an HTTPS page, it will\n     * fail. And if `options.fallbackToIP` is enabled, this will locate by IP.\n     *\n     * @param {Object} [options]\n     *        HTML5 geo-location settings with some additional options.\n     *     @param {Boolean} [options.enableHighAccuracy=true]\n     *            Specifies whether the device should provide the most accurate\n     *            position it can. Note that setting this to `true` might\n     *            consume more CPU and/or battery power; and result in slower\n     *            response times.\n     *     @param {Number} [options.timeout=6000]\n     *            HTML5 position timeout setting in milliseconds. Setting this\n     *            to `Infinity` means that Geolocator won't return until the\n     *            position is available.\n     *     @param {Number} [options.maximumAge=0]\n     *            HTML5 position maximum age. Indicates the maximum age in\n     *            milliseconds of a possible cached position that is acceptable\n     *            to return. `0` means, the device cannot use a cached position\n     *            and must attempt to retrieve the real current position. If set\n     *            to `Infinity` the device must return a cached position\n     *            regardless of its age. Note that if `enableHighAccuracy` is\n     *            set to `true`, `maximumAge` will be forced to `0`.\n     *     @param {Number} [options.desiredAccuracy=30]\n     *            Minimum accuracy desired, in meters. Position will not be\n     *            returned until this is met, before the timeout. This only\n     *            takes effect if `enableHighAccuracy` is set to `true`.\n     *     @param {Boolean} [options.fallbackToIP=false]\n     *            Specifies whether to fallback to IP geolocation if the HTML5\n     *            geolocation fails (e.g. user rejection).\n     *     @param {Boolean} [options.addressLookup=false]\n     *            Specifies whether to run a reverse-geocode operation for the\n     *            fetched coordinates to retrieve detailed address information.\n     *            Note that this means an additional request which requires a\n     *            Google API key to be set in the Geolocator configuration.\n     *            See {@link #geolocator.config|`geolocator.config()`}.\n     *     @param {Boolean} [options.timezone=false]\n     *            Specifies whether to also fetch the time zone information for\n     *            the receieved coordinates. Note that this means an additional\n     *            request which requires a Google API key to be set in the\n     *            Geolocator configuration.\n     *            See {@link #geolocator.config|`geolocator.config()`}.\n     *     @param {String|Object} [options.map]\n     *            In order to create a map from the fetched location coordinates;\n     *            either set this to map options object or; the ID of a DOM\n     *            element or DOM element itself which the map will be created\n     *            within.\n     *\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes.\n     *        This takes 2 arguments: `function (err, location) { ... }`.\n     *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var options = {\n     *     enableHighAccuracy: true,\n     *     timeout: 6000,\n     *     maximumAge: 0,\n     *     desiredAccuracy: 30,\n     *     fallbackToIP: true,\n     *     addressLookup: true,\n     *     timezone: true,\n     *     map: \"my-map\"\n     * };\n     * geolocator.locate(options, function (err, location) {\n     *     console.log(err || location);\n     * });\n     *\n     * @example\n     * // location result:\n     * {\n     *     coords: {\n     *         latitude: 37.4224764,\n     *         longitude: -122.0842499,\n     *         accuracy: 30,\n     *         altitude: null,\n     *         altitudeAccuracy: null,\n     *         heading: null,\n     *         speed: null\n     *     },\n     *     address: {\n     *         commonName: \"\",\n     *         street: \"Amphitheatre Pkwy\",\n     *         route: \"Amphitheatre Pkwy\",\n     *         streetNumber: \"1600\",\n     *         neighborhood: \"\",\n     *         town: \"\",\n     *         city: \"Mountain View\",\n     *         region: \"Santa Clara County\",\n     *         state: \"California\",\n     *         stateCode: \"CA\",\n     *         postalCode: \"94043\",\n     *         country: \"United States\",\n     *         countryCode: \"US\"\n     *     },\n     *     formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n     *     type: \"ROOFTOP\",\n     *     placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n     *     timezone: {\n     *         id: \"America/Los_Angeles\",\n     *         name: \"Pacific Standard Time\",\n     *         abbr: \"PST\",\n     *         dstOffset: 0,\n     *         rawOffset: -28800\n     *     },\n     *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n     *     map: {\n     *     \t   element: HTMLElement,\n     *     \t   instance: Object, // google.maps.Map\n     *     \t   marker: Object, // google.maps.Marker\n     *     \t   infoWindow: Object, // google.maps.InfoWindow\n     *     \t   options: Object // map options\n     *     },\n     *     timestamp: 1456795956380\n     * }\n     */\n    static locate(options, callback) {\n        options = utils.extend({\n            enableHighAccuracy: true,\n            timeout: 6000,\n            maximumAge: 0,\n            desiredAccuracy: 30,\n            fallbackToIP: false,\n            addressLookup: false,\n            timezone: false,\n            map: undefined\n        }, options);\n\n        // force disable cache if high-accuracy is enabled\n        if (options.enableHighAccuracy) options.maximumAge = 0;\n        // check options and Google key\n        checkGoogleKey(options);\n\n        let cb = callbackMap(options, callback);\n\n        function fallbackToIP(error) {\n            if (options.fallbackToIP) {\n                return geolocator.locateByIP(options, (err, location) => {\n                    if (err) return cb(err, null);\n                    return cb(null, location);\n                });\n            }\n            cb(error, null);\n        }\n        function onPositionReceived(location) {\n            fetchAddressAndTimezone(location, options, cb);\n        }\n        function onPositionError(err) {\n            err = GeoError.create(err);\n            fallbackToIP(err);\n        }\n\n        if (geolocator.isGeolocationSupported()) {\n            if (options.enableHighAccuracy) {\n                locateAccurate(options, onPositionReceived, onPositionError);\n            } else {\n                navigator.geolocation.getCurrentPosition(onPositionReceived, onPositionError, options);\n            }\n        } else {\n            let err = new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n            fallbackToIP(err);\n        }\n    }\n\n    /**\n     * Returns a location and accuracy radius based on information about cell\n     * towers and WiFi nodes that the mobile client can detect; via the Google\n     * Maps Geolocation API.\n     * @see {@link https://developers.google.com/maps/documentation/geolocation/intro|Google Maps Geolocation API}\n     * @see {@link https://developers.google.com/maps/documentation/geolocation/usage-limits|Usage Limits}\n     *\n     * @param {Object} [options]\n     *        Geolocation options.\n     *     @param {Number} [options.homeMobileCountryCode]\n     *            The mobile country code (MCC) for the device's home network.\n     *     @param {Number} [options.homeMobileNetworkCode]\n     *            The mobile network code (MNC) for the device's home network.\n     *     @param {String} [options.radioType]\n     *            The mobile radio type.\n     *            See {@link #geolocator.RadioType|`geolocator.RadioType` enumeration}\n     *            for possible values. While this field is optional, it should\n     *            be included if a value is available, for more accurate results.\n     *     @param {string} [options.carrier]\n     *            The carrier name. e.g. \"Vodafone\"\n     *     @param {Boolean} [options.fallbackToIP=false]\n     *            Specifies whether to fallback to IP geolocation if wifi and\n     *            cell tower signals are not available. Note that the IP address\n     *            in the request header may not be the IP of the device. Set\n     *            `fallbackToIP` to `false` to disable fall back.\n     *     @param {Array} [options.cellTowers]\n     *            An array of cell tower objects.\n     *            See {@link https://developers.google.com/maps/documentation/geolocation/intro#cell_tower_object|Cell tower objects} for details.\n     *     @param {Array} [options.wifiAccessPoints]\n     *            An array of WiFi access point objects.\n     *            See {@link https://developers.google.com/maps/documentation/geolocation/intro#wifi_access_point_object|WiFi access point objects} for details.\n     *     @param {Boolean} [options.addressLookup=false]\n     *            Specifies whether to run a reverse-geocode operation for the\n     *            fetched coordinates to retrieve detailed address information.\n     *            Note that this means an additional request which requires a\n     *            Google API key to be set in the Geolocator configuration.\n     *            See {@link #geolocator.config|`geolocator.config()`}.\n     *     @param {Boolean} [options.timezone=false]\n     *            Specifies whether to also fetch the time zone information for\n     *            the receieved coordinates. Note that this means an additional\n     *            request which requires a Google API key to be set in the\n     *            Geolocator configuration.\n     *            See {@link #geolocator.config|`geolocator.config()`}.\n     *     @param {String|Object} [options.map]\n     *            In order to create a map from the fetched location coordinates;\n     *            either set this to map options object or; the ID of a DOM\n     *            element or DOM element itself which the map will be created\n     *            within.\n     *     @param {Boolean} [options.raw=false]\n     *     \t      Whether to return the raw Google API result.\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes.\n     *        This takes 2 arguments: `function (err, location) { ... }`.\n     *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var options = {\n     *     homeMobileCountryCode: 310,\n     *     homeMobileNetworkCode: 410,\n     *     carrier: 'Vodafone',\n     *     radioType: geolocator.RadioType.GSM,\n     *     fallbackToIP: true,\n     *     addressLookup: false,\n     *     timezone: false,\n     *     map: \"my-map\"\n     * };\n     * geolocator.locateByMobile(options, function (err, location) {\n     *     console.log(err || location);\n     * });\n     */\n    static locateByMobile(options, callback) {\n        if (!utils.isPlainObject(options)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n        }\n\n        let cb = callbackMap(options, callback);\n\n        options = utils.extend({\n            homeMobileCountryCode: undefined,\n            homeMobileNetworkCode: undefined,\n            radioType: undefined,\n            carrier: undefined,\n            fallbackToIP: false,\n            cellTowers: undefined,\n            wifiAccessPoints: undefined,\n            addressLookup: false,\n            timezone: false,\n            map: undefined,\n            raw: false\n        }, options);\n\n        options.considerIp = options.fallbackToIP;\n        // check Google key\n        checkGoogleKey();\n\n        let conf = geolocator._.config,\n            key = conf.google.key || '',\n            url = utils.setProtocol(enums.URL.GOOGLE_GEOLOCATION, conf.https),\n            xhrOpts = {\n                url: `${url}?key=${key}`,\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                data: JSON.stringify(options)\n            };\n        // console.log(xhrOpts.data);\n\n        fetch.post(xhrOpts, (err, xhr) => {\n            let response = getXHRResponse(err, xhr);\n            if (GeoError.isGeoError(response)) return cb(response, null);\n\n            response = options.raw ? response : {\n                coords: {\n                    latitude: response.location.lat,\n                    longitude: response.location.lng,\n                    accuracy: response.accuracy\n                },\n                timestamp: utils.time()\n            };\n\n            fetchAddressAndTimezone(response, options, cb);\n\n            // e.g. raw response\n            // {\n            //     \"location\": {\n            //         \"lat\": 51.0,\n            //         \"lng\": -0.1\n            //     },\n            //     \"accuracy\": 1200.4\n            // }\n        });\n    }\n\n    /**\n     * Locates the user's location by the client's IP.\n     *\n     * This method uses Wikimedia's Geo-IP lookup service, by default.\n     * In order to change the source provider, you can use\n     * {@link #geolocator.setGeoIPSource|`geolocator.setGeoIPSource()` method}.\n     *\n     * @param {Object} [options]\n     *        Locate options.\n     *     @param {Boolean} [options.addressLookup=false]\n     *            Specifies whether to run a reverse-geocode operation for the\n     *            fetched coordinates to retrieve detailed address information.\n     *            Since no precise address can be fetched from an IP addres; you\n     *            should only enable this if the Geo-IP Source returns no useful\n     *            address information other than coordinates. Also, note that\n     *            this means an additional request which requires a Google API\n     *            key to be set in the Geolocator configuration.\n     *            See {@link #geolocator.config|`geolocator.config()`}.\n     *     @param {Boolean} [options.timezone=false]\n     *            Specifies whether to also fetch the time zone information for\n     *            the receieved coordinates. Note that this means an additional\n     *            request which requires a Google API key to be set in the\n     *            Geolocator configuration.\n     *            See {@link #geolocator.config|`geolocator.config()`}.\n     *     @param {String|Object} [options.map]\n     *            In order to create a map from the fetched location coordinates;\n     *            either set this to map options object or; the ID of a DOM\n     *            element or DOM element itself which the map will be created\n     *            within.\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes.\n     *        This takes 2 arguments: `function (err, location) { ... }`.\n     *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var options = {\n     * \t   addressLookup: true,\n     * \t   timezone: true,\n     * \t   map: \"my-map\"\n     * };\n     * geolocator.locateByIp(options, function (err, location) {\n     * \t   console.log(err || location);\n     * });\n     *\n     * @example\n     * // location result:\n     * {\n     *     coords: {\n     *         latitude: 37.4224764,\n     *         longitude: -122.0842499,\n     *     },\n     *     address: {\n     *         city: \"Istanbul\",\n     *         region: \"34\",\n     *         state: \"34\",\n     *         country: \"TR\",\n     *         countryCode: \"TR\"\n     *     },\n     *     formattedAddress: \"Demirtaş, Tesviyeci Sk. No:7, 34134 Fatih/İstanbul, Turkey\",\n     *     type: \"ROOFTOP\",\n     *     placeId: \"ChIJ-ZRLfO25yhQRBi5YJxX80Q0\",\n     *     timezone: {\n     *         id: \"Europe/Istanbul\",\n     *         name: \"Eastern European Summer Time\",\n     *         abbr: \"EEST\",\n     *         dstOffset: 3600,\n     *         rawOffset: 7200\n     *     },\n     *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/tr.svg\",\n     *     map: {\n     *     \t   element: HTMLElement,\n     *     \t   instance: Object, // google.maps.Map\n     *     \t   marker: Object, // google.maps.Marker\n     *     \t   infoWindow: Object, // google.maps.InfoWindow\n     *     \t   options: Object // map options\n     *     },\n     *     provider: \"wikimedia\",\n     *     timestamp: 1466216325223\n     * }\n     */\n    static locateByIP(options, callback) {\n        // passed source can be a string or object\n        let source = geolocator._.geoIpSource;\n\n        if (!utils.isPlainObject(source)) {\n            throw new GeoError(\n                GeoError.Code.INVALID_GEO_IP_SOURCE,\n                'Please set a valid Geo-IP Source via geolocator.setGeoIPSource(options).'\n            );\n        }\n\n        // check options and Google key\n        checkGoogleKey(options || {});\n\n        let jsonpOpts = {\n            url: source.url,\n            async: true,\n            clean: true\n            // params: {}\n        };\n        if (source.callbackParam) {\n            jsonpOpts.callbackParam = source.callbackParam;\n            jsonpOpts.rootName = 'geolocator._.cb';\n        } else if (!source.globalVar) {\n            throw new GeoError(\n                GeoError.Code.INVALID_GEO_IP_SOURCE,\n                'Either callbackParam or globalVar should be set for Geo-IP source.'\n            );\n        }\n        return fetch.jsonp(jsonpOpts, (err, response) => {\n            if (err) {\n                return callback(GeoError.create(err), null);\n            }\n            if (source.globalVar) {\n                if (window[source.globalVar]) {\n                    response = utils.clone(window[source.globalVar]);\n                    delete window[source.globalVar];\n                } else {\n                    response = null;\n                }\n            }\n            if (!response) {\n                err = new GeoError(GeoError.Code.INVALID_RESPONSE);\n                return callback(err, null);\n            }\n            if (utils.isPlainObject(source.schema)) {\n                response = utils.mapToSchema(response, source.schema);\n            }\n            response.provider = source.provider || 'unknown';\n            setFlagURL(response);\n            if (response.coords) {\n                response.coords.latitude = Number(response.coords.latitude);\n                response.coords.longitude = Number(response.coords.longitude);\n            }\n            let cb = callbackMap(options, callback);\n            fetchAddressAndTimezone(response, options, cb);\n        });\n    }\n\n    /**\n     * Sets the Geo-IP source to be used for fetching location information\n     * by user's IP; which is internally used by\n     * {@link #geolocator.locateByIP|`geolocator.locateByIP()` method}.\n     *\n     * By default, Geolocator uses Wikimedia as the Geo-IP source provider.\n     * You can use this method to change this; or you can choose from\n     * ready-to-use\n     * {@link https://github.com/onury/geolocator/tree/master/src/geo-ip-sources|Geo-IP sources}.\n     *\n     * @param {Object} options\n     *        Geo-IP Source options.\n     *     @param {String} [options.provider]\n     *            Source or service provider's name.\n     *     @param {String} options.url\n     *            Source URL without the callback query parameter. The callback\n     *            name (if supported) should be set via `options.callbackParam`.\n     *            Also, make sure the service supports the protocol you use in\n     *            the enums.URL. If it supports both HTTP and HTTPS, you can omit the\n     *            protocol. In this case, it will be determined via Geolocator\n     *            configuration.\n     *            See {@link #geolocator.config|`geolocator.config()`}.\n     *            NOTE: Do not forget to include your API key in the query\n     *            parameters of the URL, if you have one.\n     *     @param {String} [options.callbackParam]\n     *            If JSON callback is supported, pass the name of the callback\n     *            parameter, defined by the provider.\n     *     @param {Object} [options.globalVar]\n     *            Set this instead of `options.callbackParam` if the service\n     *            does not support JSON callbacks, but weirdly set a global\n     *            variable in the document. For example, if the response is\n     *            `Geo = { lat, lng }`, you should set this to `\"Geo\"`.\n     *     @param {Object} [options.schema]\n     *            Schema object to be used to re-structure the response returned\n     *            from the service. Set the response object's keys as values of\n     *            a custom object to map the format to the `location` object.\n     *            For example; if the service returns a response like\n     *            `{ lat: 40.112233, lng: 10.112233, otherProp: 'hello' }`.\n     *            Then you should set the following schema:\n     *            `{ coords: { latitude: 'lat', longitude: 'lng' } }`.\n     *\n     * @return {geolocator}\n     */\n    static setGeoIPSource(options) {\n        if (!utils.isPlainObject(options)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'Geo-IP source options is invalid.');\n        }\n        if (!utils.isStringSet(options.url)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'Geo-IP source should have a valid URI.');\n        }\n        // if (!utils.isStringSet(options.callbackParam) && !utils.isStringSet(options.globalVar)) {\n        //     throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'No \\'callbackParam\\' or \\'globalVar\\' is provided for the Geo-IP Source options.');\n        // }\n        geolocator._.geoIpSource = Object.freeze(options);\n    }\n\n    /**\n     * Registers a handler for watching the user's location via HTML5\n     * geolocation; that is triggered each time the position of the device\n     * changes. This may require/prompt for user's permission.\n     *\n     * @param {Object} [options]\n     *        HTML5 geo-location settings.\n     *     @param {Boolean} [options.enableHighAccuracy=true]\n     *            Specifies whether the device should provide the most accurate\n     *            position it can. Note that setting this to `true` might consume\n     *            more CPU and/or battery power; and result in slower response\n     *            times.\n     *     @param {Number} [options.timeout=6000]\n     *            HTML5 position timeout setting in milliseconds. Setting this\n     *            to `Infinity` means that Geolocator won't return until the\n     *            position is available.\n     *     @param {Number} [options.maximumAge=0]\n     *            HTML5 position maximum age. Indicates the maximum age in\n     *            milliseconds of a possible cached position that is acceptable\n     *            to return. `0` means, the device cannot use a cached position\n     *            and must attempt to retrieve the real current position. If set\n     *            to `Infinity` the device must return a cached position\n     *            regardless of its age.\n     *     @param {Boolean} [options.clearOnError=false]\n     *            Specifies whether to clear the watcher on first error so that\n     *            it does not execute any more callbacks.\n     *     @param {Object} [options.target]\n     *            Object that defines the target location and settings; that\n     *            when the location is reached, the watcher will auto-clear\n     *            itself and invoke the callback.\n     *     @param {Number} options.target.latitude\n     *            The `latitude` of the target location.\n     *     @param {Number} options.target.longitude\n     *            The `longitude` of the target location.\n     *     @param {Number} [options.target.radius=0.5]\n     *            The radius, in other words; the minimum distance (in\n     *            kilometers or miles) to the target point that should be\n     *            reached.\n     *     @param {Number} [options.target.unitSystem=0]\n     *            Unit system to be used for target radius.\n     *            See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n     *            for possible values.\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes.\n     *        This takes 2 arguments: `function (err, location) { ... }`.\n     *        If `options.target` is set, `location` will also\n     *        include a `targetReached:Boolean` property.\n     *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     * @returns {GeoWatcher} - A watcher object that provides a\n     * `.clear(delay:Number, callback:Function)` method to clear the watcher\n     * when needed. Optional `delay` argument can be set (in milliseconds) to\n     * clear in a later time. Omitting this argument will clear the watcher\n     * immediately. You should always call this method, except if you've set up\n     * a target; which will auto-clear the watcher when reached.\n     *\n     * @example\n     * // Watch my position for 5 minutes.\n     * var options = { enableHighAccuracy: true, timeout: 6000, maximumAge: 0 };\n     * var watcher = geolocator.watch(options, function (err, location) {\n     *     console.log(err || location);\n     * });\n     * console.log(watcher.id); // ID of the watcher\n     * watcher.clear(300000); // clear after 5 minutes.\n     *\n     * @example\n     * // Watch my position until I'm 350 meters near Disneyland Park.\n     * options.target = {\n     *     latitude: 33.8120918,\n     *     longitude: -117.9233569,\n     *     radius: 0.35,\n     *     unitSystem: geolocator.UnitSystem.METRIC\n     * };\n     * watcher = geolocator.watch(options, function (err, location) {\n     *     if (err) {\n     *         console.log(err);\n     *         return;\n     *     }\n     *     if (location.targetReached) {\n     *         console.log(watcher.isCleared); // true\n     *         console.log(watcher.cycle); // 15 — target reached after 15 cycles\n     *     } else {\n     *         console.log(watcher.isCleared); // false — watcher is active.\n     *     }\n     * });\n     */\n    static watch(options, callback) {\n        if (!geolocator.isGeolocationSupported()) {\n            callback(new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED), null);\n            return {};\n        }\n\n        let watcher, target;\n\n        options = utils.extend({\n            enableHighAccuracy: true,\n            timeout: 6000,\n            maximumAge: 0,\n            clearOnError: false\n        }, options);\n\n        if (utils.isPlainObject(options.target)) {\n            target = utils.extend({\n                radius: 0.5,\n                unitSystem: geolocator.UnitSystem.METRIC\n            }, options.target);\n        }\n\n        function onPositionChanged(location) {\n            let pos = utils.clone(location, { own: false });\n            if (target) {\n                let distance = geolocator.calcDistance({\n                    from: location.coords,\n                    to: target,\n                    formula: geolocator.DistanceFormula.HAVERSINE,\n                    unitSystem: target.unitSystem\n                });\n                pos.targetReached = distance <= target.radius;\n                if (watcher && pos.targetReached) {\n                    watcher.clear(() => {\n                        return callback(null, pos);\n                    });\n                }\n            }\n            return callback(null, pos);\n        }\n        function onPositionError(err) {\n            callback(GeoError.create(err), null);\n        }\n        return new GeoWatcher(onPositionChanged, onPositionError, options);\n    }\n\n    /**\n     * Converts a given address (or address components) into geographic\n     * coordinates (i.e. latitude, longitude); and gets detailed address\n     * information.\n     * @see {@link https://developers.google.com/maps/documentation/geocoding/intro|Google Maps Geocoding API}\n     * @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n     *\n     * @param {String|Object} options\n     *        Either the address to geocode or geocoding options with the\n     *        following properties.\n     *     @param {String} options.address\n     *            The street address to geocode, in the format used by the\n     *            national postal service of the country concerned. Additional\n     *            address elements such as business names and unit, suite or\n     *            floor numbers should be avoided. Note that any address\n     *            component (route, locality, administrativeArea, postalCode and\n     *            country) should be specified either in address or the\n     *            corresponding property - not both. Doing so may result in\n     *            `ZERO_RESULTS`.\n     *     @param {String} [options.route]\n     *     \t      Long or short name of a route.\n     *     @param {String} [options.locality]\n     *     \t      Locality and sublocality of the location.\n     *     @param {String} [options.administrativeArea]\n     *     \t      Administrative area of the location.\n     *     @param {String} [options.postalCode]\n     *     \t      Postal code of the location.\n     *     @param {String} [options.country]\n     *     \t      A country name or a two letter ISO 3166-1 country code.\n     *     @param {String} [options.region]\n     *     \t      The region code, specified as a ccTLD (\"top-level domain\")\n     *     \t      two-character value. e.g.: `\"fr\"` for France.\n     *     @param {Array|Object} [options.bounds]\n     *     \t      The bounding box of the viewport within which to bias geocode\n     *     \t      results more prominently. e.g.:\n     *     \t      `[ southwestLat:Number, southwestLng:Number, northeastLat:Number, northeastLng:Number ]`\n     *     @param {String|Object} [options.map]\n     *            In order to create a map from the fetched location coordinates;\n     *            either set this to map options object or; the ID of a DOM\n     *            element or DOM element itself which the map will be created\n     *            within.\n     *     @param {Boolean} [options.raw=false]\n     *     \t      Whether to return the raw Google API result.\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes.\n     *        This takes 2 arguments: `function (err, location) { ... }`.\n     *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var address = '1600 Amphitheatre Parkway, CA';\n     * geolocator.geocode(address, function (err, location) {\n     *     console.log(err || location);\n     * });\n     *\n     * @example\n     * // location result:\n     * {\n     *     coords: {\n     *         latitude: 37.4224764,\n     *         longitude: -122.0842499\n     *     },\n     *     address: {\n     *         commonName: \"\",\n     *         street: \"Amphitheatre Pkwy\",\n     *         route: \"Amphitheatre Pkwy\",\n     *         streetNumber: \"1600\",\n     *         neighborhood: \"\",\n     *         town: \"\",\n     *         city: \"Mountain View\",\n     *         region: \"Santa Clara County\",\n     *         state: \"California\",\n     *         stateCode: \"CA\",\n     *         postalCode: \"94043\",\n     *         country: \"United States\",\n     *         countryCode: \"US\"\n     *     },\n     *     formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n     *     type: \"ROOFTOP\",\n     *     placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n     *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n     *     map: {\n     *     \t   element: HTMLElement,\n     *     \t   instance: Object, // google.maps.Map\n     *     \t   marker: Object, // google.maps.Marker\n     *     \t   infoWindow: Object, // google.maps.InfoWindow\n     *     \t   options: Object // map options\n     *     },\n     *     timestamp: 1456795956380\n     * }\n     */\n    static geocode(options, callback) {\n        geocode(false, options, callback);\n    }\n\n    /**\n     * Converts the given geographic coordinates into a human-readable address\n     * information.\n     * @see {@link https://developers.google.com/maps/documentation/geocoding/intro#ReverseGeocoding|Google Maps (Reverse) Geocoding API}\n     * @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n     * @alias geolocator.addressLookup\n     *\n     * @param {Object|String} options\n     *        Either the `placeId` of the location or Reverse Geocoding options\n     *        with the following properties.\n     *     @param {Number} options.latitude\n     *     Latitude of the target location.\n     *     @param {Number} options.longitude\n     *     Longitude of the target location.\n     *     @param {String} [options.placeId]\n     *            Required if `latitude` and `longitude` are omitted. The place\n     *            ID of the place for which you wish to obtain the\n     *            human-readable address. The place ID is a unique identifier\n     *            that can be used with other Google APIs. Note that if\n     *            `placeId` is set, `latitude` and `longitude` are ignored.\n     *     @param {String|Object} [options.map]\n     *            In order to create a map from the given location coordinates;\n     *            either set this to map options object or; the ID of a DOM\n     *            element or DOM element itself which the map will be created\n     *            within.\n     *     @param {Boolean} [options.raw=false]\n     *            Whether to return the raw Google API result.\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes.\n     *        This takes 2 arguments: `function (err, location) { ... }`\n     *        See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var coords = {\n     *     latitude: 37.4224764,\n     *     longitude: -122.0842499\n     * };\n     *\n     * geolocator.reverseGeocode(coords, function (err, location) {\n     *     console.log(err || location);\n     * });\n     *\n     * @example\n     * // location result:\n     * {\n     *     coords: {\n     *         latitude: 37.4224764,\n     *         longitude: -122.0842499\n     *     },\n     *     address: {\n     *         commonName: \"\",\n     *         street: \"Amphitheatre Pkwy\",\n     *         route: \"Amphitheatre Pkwy\",\n     *         streetNumber: \"1600\",\n     *         neighborhood: \"\",\n     *         town: \"\",\n     *         city: \"Mountain View\",\n     *         region: \"Santa Clara County\",\n     *         state: \"California\",\n     *         stateCode: \"CA\",\n     *         postalCode: \"94043\",\n     *         country: \"United States\",\n     *         countryCode: \"US\"\n     *     },\n     *     formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n     *     type: \"ROOFTOP\",\n     *     placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n     *     flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n     *     map: {\n     *     \t   element: HTMLElement,\n     *     \t   instance: Object, // google.maps.Map\n     *     \t   marker: Object, // google.maps.Marker\n     *     \t   infoWindow: Object, // google.maps.InfoWindow\n     *     \t   options: Object // map options\n     *     },\n     *     timestamp: 1456795956380\n     * }\n     */\n    static reverseGeocode(options, callback) {\n        geocode(true, options, callback);\n    }\n\n    /**\n     *  Alias for `geolocator.reverseGeocode`\n     *  @private\n     */\n    static addressLookup(options, callback) {\n        geolocator.reverseGeocode(options, callback);\n    }\n\n    /**\n     * Gets timezone information for the given coordinates.\n     * Note: Google Browser API keys cannot have referer restrictions when used with this API.\n     * @see {@link https://developers.google.com/maps/documentation/timezone/intro|Google Maps TimeZone API}\n     * @see {@link https://developers.google.com/maps/documentation/timezone/usage-limits|Usage Limits}\n     *\n     * @param {Object} options\n     *        Time zone options.\n     *     @param {Number} options.latitude\n     *            Latitude of location.\n     *     @param {Number} options.longitude\n     *            Longitude of location.\n     *     @param {Number} [options.timestamp=Date.now()]\n     *            Specifies the desired time as seconds since midnight, January\n     *            1, 1970 UTC. This is used to determine whether or not Daylight\n     *            Savings should be applied.\n     *     @param {Boolean} [options.raw=false]\n     *            Whether to return the raw Google API result.\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes, in\n     *        the following signature: `function (err, timezone) { ... }`.\n     *        See {@link #geolocator~TimeZone|`geolocator~TimeZone` type} for\n     *        details.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var options = {\n     *     latitude: 48.8534100,\n     *     longitude: 2.3488000\n     * };\n     * geolocator.getTimeZone(options, function (err, timezone) {\n     *     console.log(err || timezone);\n     * });\n     *\n     * @example\n     * // timezone result:\n     * {\n     *     id: \"Europe/Paris\",\n     *     name: \"Central European Standard Time\",\n     *     abbr: \"CEST\",\n     *     dstOffset: 0,\n     *     rawOffset: 3600,\n     *     timestamp: 1455733120\n     * }\n     */\n    static getTimeZone(options, callback) {\n        if (!utils.isPlainObject(options)\n                || !utils.isNumber(options.latitude)\n                || !utils.isNumber(options.longitude)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n        }\n\n        checkGoogleKey();\n\n        let conf = geolocator._.config;\n        options = utils.extend({\n            key: conf.google.key || '',\n            language: conf.language || 'en',\n            timestamp: utils.time(true),\n            raw: false\n        }, options);\n\n        let url = utils.setProtocol(enums.URL.GOOGLE_TIMEZONE, conf.https),\n            xhrOpts = {\n                url: `${url}?location=${options.latitude},${options.longitude}&timestamp=${options.timestamp}&language=${options.language}&key=${options.key}`\n            };\n\n        fetch.xhr(xhrOpts, (err, xhr) => {\n            let response = getXHRResponse(err, xhr);\n            if (GeoError.isGeoError(response)) return callback(response, null);\n\n            response = options.raw ? response : {\n                id: response.timeZoneId,\n                name: response.timeZoneName,\n                abbr: utils.abbr(response.timeZoneName, { dots: false }),\n                dstOffset: response.dstOffset,\n                rawOffset: response.rawOffset,\n                timestamp: options.timestamp\n            };\n            callback(err, response);\n        });\n    }\n\n    /**\n     * Gets the distance and duration values based on the recommended route\n     * between start and end points.\n     * @see {@link https://developers.google.com/maps/documentation/distance-matrix/intro|Google Maps Distance Matrix API}\n     * @see {@link https://developers.google.com/maps/documentation/distance-matrix/usage-limits|Usage Limits}\n     *\n     * @param {Object} options\n     *        Distance matrix options.\n     *     @param {String|Object|Array} options.origins\n     *            One or more addresses and/or an object of latitude/longitude\n     *            values, from which to calculate distance and time. If you pass\n     *            an address as a string, the service will geocode the string\n     *            and convert it to a latitude/longitude coordinate to calculate\n     *            distances. Following are valid examples:\n     * <pre><code>options.origins = 'London';\n     * options.origins = ['London', 'Paris'];\n     * options.origins = { latitude: 51.5085300, longitude: -0.1257400 };\n     * options.origins = [\n     *     { latitude: 51.5085300, longitude: -0.1257400 },\n     *     { latitude: 48.8534100, longitude: 2.3488000 }\n     * ];\n     * </code></pre>\n     *     @param {String|Object|Array} options.destinations\n     *            One or more addresses and/or an object of latitude/longitude\n     *            values, from which to calculate distance and time. If you pass\n     *            an address as a string, the service will geocode the string\n     *            and convert it to a latitude/longitude coordinate to calculate\n     *            distances.\n     *     @param {String} [options.travelMode=\"DRIVING\"]\n     *            Type of routing requested.\n     *            See {@link #geolocator.TravelMode|`geolocator.TravelMode` enumeration}\n     *            for possible values.\n     *     @param {Boolean} [options.avoidFerries]\n     *            If true, instructs the Distance Matrix service to avoid\n     *            ferries where possible.\n     *     @param {Boolean} [options.avoidHighways]\n     *            If true, instructs the Distance Matrix service to avoid\n     *            highways where possible.\n     *     @param {Boolean} [options.avoidTolls]\n     *            If true, instructs the Distance Matrix service to avoid toll\n     *            roads where possible.\n     *     @param {Number} [options.unitSystem=0]\n     *            Preferred unit system to use when displaying distance.\n     *            See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n     *            for possible values.\n     *     @param {String} [options.region]\n     *            Region code used as a bias for geocoding requests.\n     * @param {Boolean} [options.raw=false]\n     *        Whether to return the raw Google API result.\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes,\n     *        in the following signature: `function (err, result) { ... }`\n     *\n     * @returns {void}\n     *\n     * @example\n     * var options = {\n     *     origins: [{ latitude: 51.5085300, longitude: -0.1257400 }],\n     *     destinations: [{ latitude: 48.8534100, longitude: 2.3488000 }],\n     *     travelMode: geolocator.TravelMode.DRIVING,\n     *     unitSystem: geolocator.UnitSystem.METRIC\n     * };\n     * geolocator.getDistanceMatrix(options, function (err, result) {\n     *     console.log(err || result);\n     * });\n     *\n     * @example\n     * // result:\n     * [\n     * \t{\n     * \t\tfrom: \"449 Duncannon St, London WC2R 0DZ, UK\",\n     * \t\tto: \"1 Parvis Notre-Dame - Pl. Jean-Paul II, 75004 Paris-4E-Arrondissement, France\",\n     * \t\tdistance: {\n     * \t\t\tvalue: 475104,\n     * \t\t\ttext: \"475 km\"\n     * \t\t},\n     * \t\tduration: {\n     * \t\t\tvalue: 20193,\n     * \t\t\ttext: \"5 hours 37 mins\"\n     * \t\t},\n     * \t\tfare: undefined,\n     * \t\ttimestamp: 1456795956380\n     * \t}\n     * ]\n     */\n    static getDistanceMatrix(options, callback) {\n        checkGoogleKey();\n\n        let key = geolocator._.config.google.key;\n        geolocator.ensureGoogleLoaded(key, err => {\n            if (err) {\n                throw new GeoError(GeoError.Code.GOOGLE_API_FAILED, String(err.message || err));\n            }\n\n            let o = options.origins || options.origin || options.from,\n                d = options.destinations || options.destination || options.to;\n            if (!utils.isPlainObject(options) || invalidOriginOrDest(o) || invalidOriginOrDest(d)) {\n                throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n            }\n            options.origins = geoHelper.toPointList(o);\n            options.destinations = geoHelper.toPointList(d);\n\n            options = utils.extend({\n                travelMode: google.maps.TravelMode.DRIVING,\n                avoidFerries: undefined,\n                avoidHighways: undefined,\n                avoidTolls: undefined,\n                unitSystem: google.maps.UnitSystem.METRIC\n            }, options);\n\n            let service = new google.maps.DistanceMatrixService();\n            service.getDistanceMatrix(options, (response, status) => {\n                let err = null;\n                if (status !== google.maps.DistanceMatrixStatus.OK) {\n                    err = GeoError.fromResponse(status)\n                        || GeoError.fromResponse(response);\n                    response = null;\n                } else {\n                    response = options.raw ? response : geoHelper.formatDistanceResults(response);\n                }\n                callback(err, response);\n            });\n        });\n    }\n\n    /**\n     * Calculates the distance between two geographic points.\n     *\n     * @param {Object} options\n     *        Calculation and display options.\n     *     @param {Object} options.from\n     *            Object containing the `latitude` and `longitude` of original\n     *            location.\n     *     @param {Object} options.to\n     *            Object containing the `latitude` and `longitude` of destination.\n     *     @param {String} [options.formula=\"haversine\"]\n     *            The algorithm or formula to calculate the distance.\n     *            See {@link #geolocator.DistanceFormula|`geolocator.DistanceFormula` enumeration}.\n     *     @param {Number} [options.unitSystem=0]\n     *            Preferred unit system to use when displaying distance.\n     *            See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}.\n     *\n     * @returns {Number} - The calculated distance.\n     *\n     * @example\n     * // Calculate distance from London to Paris.\n     * var result = geolocator.calcDistance({\n     *     from: {\n     *         latitude: 51.5085300,\n     *         longitude: -0.1257400\n     *     },\n     *     to: {\n     *         latitude: 48.8534100,\n     *         longitude: 2.3488000\n     *     },\n     *     formula: geolocator.DistanceFormula.HAVERSINE,\n     *     unitSystem: geolocator.UnitSystem.METRIC\n     * });\n     * // result: 366.41656039126093 (kilometers)\n     */\n    static calcDistance(options) {\n        options = utils.extend({\n            formula: geolocator.DistanceFormula.HAVERSINE,\n            unitSystem: geolocator.UnitSystem.METRIC\n        }, options);\n\n        let from = options.from,\n            to = options.to,\n            radius = options.unitSystem === geolocator.UnitSystem.METRIC\n                ? EARTH_RADIUS_KM : EARTH_RADIUS_MI;\n\n        if (options.formula === geolocator.DistanceFormula.HAVERSINE) {\n            let dLat = geolocator.degToRad(to.latitude - from.latitude),\n                dLng = geolocator.degToRad(to.longitude - from.longitude),\n                a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                    Math.cos(geolocator.degToRad(from.latitude)) *\n                    Math.cos(geolocator.degToRad(to.longitude)) *\n                    Math.sin(dLng / 2) * Math.sin(dLng / 2),\n                c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n            return radius * c;\n        }\n        // geolocator.DistanceFormula.PYTHAGOREAN\n        let latA = geolocator.degToRad(from.latitude),\n            latB = geolocator.degToRad(to.latitude),\n            lngA = geolocator.degToRad(from.longitude),\n            lngB = geolocator.degToRad(to.longitude),\n            x = (lngB - lngA) * Math.cos((latA + latB) / 2),\n            y = (latB - latA);\n        return Math.sqrt(x * x + y * y) * radius;\n    }\n\n    /**\n     * Gets the current public IP of the client.\n     *\n     * @param {Function} callback\n     *        Callback function to be executed when the request completes, in\n     *        the following signature: `function (err, result) { ... }`\n     *\n     * @returns {void}\n     *\n     * @example\n     * geolocator.getIP(function (err, result) {\n     *     console.log(err || result);\n     * });\n     *\n     * @example\n     * // result:\n     * {\n     *     ip: \"176.232.71.155\",\n     *     timestamp: 1457573683427\n     * }\n     */\n    static getIP(callback) {\n        let conf = geolocator._.config;\n\n        let jsonpOpts = {\n            url: utils.setProtocol(enums.URL.IP, conf.https),\n            async: true,\n            clean: true,\n            params: {\n                format: 'jsonp'\n            },\n            callbackParam: 'callback',\n            rootName: 'geolocator._.cb'\n        };\n        return fetch.jsonp(jsonpOpts, (err, response) => {\n            if (err) {\n                return callback(GeoError.create(err), null);\n            }\n            if (!response) {\n                err = new GeoError(GeoError.Code.INVALID_RESPONSE);\n                return callback(err, null);\n            }\n            if (typeof response === 'object') response.timestamp = utils.time();\n            callback(null, response);\n        });\n    }\n\n    /**\n     * Ensures Google Maps API is loaded. If not, this will load all of the\n     * main Javascript objects and symbols for use in the Maps API.\n     *\n     * Note that, Google Maps API is loaded only when needed. For example,\n     * the DistanceMatrix API does not support Web Service requests and\n     * requires this API to be loaded. However, the TimeZone API requests are\n     * made throught the Web Service without requiring a `google` object\n     * within DOM.\n     *\n     * Also note that this will not re-load the API if `google.maps` object\n     * already exists. In this case, the `callback` is still executed and\n     * no errors are passed.\n     *\n     * You can use the following overload to omit the `key` argument altogether:\n     *\n     * `geolocator.ensureGoogleLoaded(callback)`\n     *\n     * @param {String} [key]\n     *        Google API key.\n     * @param {Function} callback\n     *        Callback function to be executed when the operation ends.\n     *\n     * @returns {void}\n     *\n     * @example\n     * geolocator.ensureGoogleLoaded(function (err) {\n     * \t   if (err) return;\n     * \t   console.log('google' in window); // true\n     * });\n     */\n    static ensureGoogleLoaded(key, callback) {\n        let k;\n        if (utils.isFunction(key)) {\n            callback = key;\n        } else {\n            k = key;\n        }\n        if (!geolocator.isGoogleLoaded()) {\n            let jsonpOpts = {\n                url: enums.URL.GOOGLE_MAPS_API,\n                async: true,\n                callbackParam: 'callback',\n                params: {\n                    key: k || ''\n                    // callback: ''\n                },\n                rootName: 'geolocator._.cb'\n            };\n            return fetch.jsonp(jsonpOpts, callback);\n        }\n        callback();\n    }\n\n    /**\n     * Checks whether the Google Maps API is loaded.\n     *\n     * @returns {Boolean} - Returns `true` if already loaded.\n     */\n    static isGoogleLoaded() {\n        return ('google' in window) && google.maps;\n    }\n\n    /**\n     * Checks whether the type of the given object is an HTML5 `PositionError`.\n     *\n     * @param {*} obj - Object to be checked.\n     * @return {Boolean}\n     */\n    static isPositionError(obj) {\n        return utils.isPositionError(obj);\n    }\n\n    /**\n     * Checks whether the given value is an instance of `GeoError`.\n     *\n     * @param {*} obj - Object to be checked.\n     * @return {Boolean}\n     */\n    static isGeoError(obj) {\n        return GeoError.isGeoError(obj);\n    }\n\n    /**\n     * Checks whether HTML5 Geolocation API is supported.\n     *\n     * @return {Boolean}\n     */\n    static isGeolocationSupported() {\n        return navigator && ('geolocation' in navigator);\n    }\n\n    /**\n     * Converts kilometers to miles.\n     *\n     * @param {Number} km - Kilometers to be converted.\n     * @returns {Number} - Miles.\n     */\n    static kmToMi(km) {\n        return km * 0.621371;\n    }\n\n    /**\n     * Converts miles to kilometers.\n     *\n     * @param {Number} mi - Miles to be converted.\n     * @returns {Number} - Kilometers.\n     */\n    static miToKm(mi) {\n        return mi / 0.621371;\n    }\n\n    /**\n     * Converts degrees to radians.\n     *\n     * @param {Number} deg - Degrees to be converted.\n     * @returns {Number} - Radians.\n     */\n    static degToRad(degrees) {\n        return degrees * (Math.PI / 180);\n    }\n\n    /**\n     * Converts radians to degrees.\n     *\n     * @param {Number} rad - Radians to be converted.\n     * @returns {Number} - Degrees.\n     */\n    static radToDeg(radians) {\n        return radians * (180 / Math.PI);\n    }\n\n    /**\n     * Converts decimal coordinates (either lat or lng) to degrees, minutes, seconds.\n     *\n     * @param {Number} dec\n     *        Decimals to be converted.\n     * @param {Boolean} [isLng=false]\n     *        Indicates whether the given decimals is longitude.\n     *\n     * @returns {String} - Degrees, minutes, seconds.\n     */\n    static decToDegMinSec(dec, isLng = false) {\n        // Degrees Latitude must be in the range of -90. to 90.\n        // Degrees Longitude must be in the range of -180 to 180.\n        // +Latitude is North, -Latitude is South\n        // +Longitude is East, -Longitude is West\n        let sign = dec < 0 ? -1 : 1,\n            sn = dec < 0 ? 'S' : 'N',\n            we = dec < 0 ? 'W' : 'E',\n            nsew = !isLng ? sn : we,\n            absValue = Math.abs(Math.round(dec * 1000000.0));\n        return ((Math.floor(absValue / 1000000) * sign) + '° ' + Math.floor(((absValue / 1000000) - Math.floor(absValue / 1000000)) * 60) + '\\' ' +\n                (Math.floor(((((absValue / 1000000) - Math.floor(absValue / 1000000)) * 60) - Math.floor(((absValue / 1000000) - Math.floor(absValue / 1000000)) * 60)) * 100000) * 60 / 100000) + '\" ') + nsew;\n    }\n\n}\n\n// ---------------------------\n// HELPER METHODS\n// ---------------------------\n\n/**\n *  Used with distance matrix calls.\n *  @private\n */\nfunction invalidOriginOrDest(value) {\n    return !utils.isString(value)\n        && !utils.isArray(value)\n        && !utils.isPlainObject(value);\n}\n\n/**\n *  Check if XHR response is an error response and returns a `GeoError`.\n *  If not, returns the parsed response.\n *  @private\n *\n *  @param {Error} err\n *         XHR error.\n *  @param {Object} xhr\n *         XHR object to be checked.\n *\n *  @returns {GeoError|Object}\n */\nfunction getXHRResponse(err, xhr) {\n    if (err) return GeoError.create(err);\n    if (!xhr) return new GeoError(GeoError.Code.REQUEST_FAILED);\n    let response = utils.safeJsonParse(xhr.responseText);\n    // Check if XHR response is an error response.\n    // return response if not.\n    return GeoError.fromResponse(response) || response;\n}\n\n/**\n *  Checks the given options and determines if Google key is required.\n *  Throws if key is required but not set or valid.\n *  @private\n *\n *  @param {Object} [options]\n *         Options to be checked. If `undefined`, directly checks Googke key.\n */\nfunction checkGoogleKey(options) {\n    if (!options || (options.addressLookup || options.timezone || options.map)) {\n        if (!geolocator._.config.google.key) {\n            throw new GeoError(GeoError.Code.GOOGLE_KEY_INVALID, 'A Google API key is required but it\\'s not set or valid.');\n        }\n    }\n}\n\n/**\n *  Checks and adds necessary properties to map options from the given location\n *  result object. This is used with methods that support `map` option; to\n *  create a map from the result coordinates; such as locate() method.\n *  @private\n *\n *  @param {Object|String} options\n *         Original options object.\n *  @param {Object} location\n *         Location result object.\n *\n *  @returns {Object} - Final map options object.\n */\nfunction getMapOpts(mapOptions, location) {\n    if (utils.isObject(mapOptions)) {\n        mapOptions.center = location.coords;\n    } else {\n        mapOptions = {\n            element: mapOptions,\n            center: location.coords\n        };\n    }\n    // this will enable infoWindow\n    if (location.formattedAddress) {\n        mapOptions.title = location.formattedAddress;\n    }\n    // if location has accuracy, (and zoom is not set) we can zoom in a bit more\n    if (!mapOptions.zoom\n            && location.coords\n            && utils.isNumber(location.coords.accuracy)\n            && location.coords.accuracy < 1500) {\n        mapOptions.zoom = 15;\n    }\n    return mapOptions;\n}\n\n/**\n *  Checks the HTMLElement to see whether a previous map and related objects\n *  (marker, infoWindow) are created for it; by checking our private property\n *  `_geolocatorMapData`. If there is a map, this does not re-create it (which\n *  will break the map) but only re-adjust center, zoom and re-create the marker\n *  if needed. We use this approach bec. Google maps has no feature to destroy\n *  a map. This is considered a bug by Google developers.\n *  @private\n *\n *  @param {Object} options\n *         Options for creating a map.\n */\nfunction configCreateMap(options) {\n    let elem = options.element,\n        // when geolocator creates a map, it will set a `_geolocatorMapData`\n        // property on the element. So we can use this map instance later,\n        // when the same HTMLElement is passed to create a map. So check if\n        // we have it here.\n        mapData = elem._geolocatorMapData,\n        map = (mapData && mapData.instance) || null,\n        marker = (mapData && mapData.marker) || null,\n        infoWindow = (mapData && mapData.infoWindow) || null,\n        center = new google.maps.LatLng(options.center.latitude, options.center.longitude),\n        mapOptions = {\n            mapTypeId: options.mapTypeId,\n            center: center,\n            zoom: options.zoom\n        };\n\n    // if we have a map, we'll just configure it. otherwise, we'll create\n    // one.\n    if (map) {\n        map.setMapTypeId(mapOptions.mapTypeId);\n        map.setCenter(mapOptions.center);\n        map.setZoom(mapOptions.zoom);\n    } else {\n        map = new google.maps.Map(options.element, mapOptions);\n    }\n\n    // destroy marker and infoWindow if previously created for this element.\n    if (infoWindow) infoWindow = null;\n    if (marker && marker instanceof google.maps.Marker) {\n        google.maps.event.clearInstanceListeners(marker);\n        marker.setMap(null);\n        marker = null;\n    }\n\n    // check the new options to see if we need to re-create a marker for\n    // this.\n    if (options.marker) {\n        marker = new google.maps.Marker({\n            position: mapOptions.center,\n            map: map\n        });\n        if (options.title) {\n            infoWindow = new google.maps.InfoWindow();\n            infoWindow.setContent(options.title);\n            // infoWindow.open(map, marker);\n            google.maps.event.addListener(marker, 'click', () => {\n                infoWindow.open(map, marker);\n            });\n        }\n    }\n\n    mapData = {\n        element: elem,\n        instance: map,\n        marker: marker,\n        infoWindow: infoWindow,\n        options: mapOptions\n    };\n    // set the reference on the element for later use, if needed.\n    elem._geolocatorMapData = mapData;\n    return mapData;\n}\n\n/**\n *  Sets the `flag` property of the given location.\n *  @private\n *\n *  @param {Object} location\n */\nfunction setFlagURL(location) {\n    if (!location || !location.address) return;\n    let cc,\n        address = location.address;\n    if (utils.isString(address.countryCode) && address.countryCode.length === 2) {\n        cc = address.countryCode;\n    } else if (utils.isString(address.country) && address.country.length === 2) {\n        cc = address.country;\n    }\n    if (!cc) return;\n    location.flag = enums.URL.FLAG + cc.toLowerCase() + '.svg';\n}\n\n/**\n *  Nests `createMap` callback within the given callback.\n *  @private\n *\n *  @param {Object} options\n *         Method options.\n *  @param {Function} callback\n *         Parent callback.\n *\n *  @returns {Function} - Nested callback.\n */\nfunction callbackMap(options, callback) {\n    return function cb(err, location) {\n        if (err) return callback(GeoError.create(err), null);\n        setFlagURL(location);\n        if (!options.map) return callback(null, location);\n        options.map = getMapOpts(options.map, location);\n        geolocator.createMap(options.map, (error, map) => {\n            if (error) return callback(error, null);\n            location.map = map;\n            return callback(null, location);\n        });\n    };\n}\n\n/**\n *  Sends a geocode or reverse-geocode request with the given options.\n *  @private\n *\n *  @param {Boolean} reverse\n *         Whether to send reverse-geocode request.\n *  @param {Object} options\n *         Geocode options.\n *  @param {Function} callback\n *         Callback to be nested and executed with map callback.\n */\nfunction geocode(reverse, options, callback) {\n    checkGoogleKey();\n    geoHelper.geocode(\n        reverse,\n        geolocator._.config,\n        options,\n        callbackMap(options, callback)\n    );\n}\n\n/**\n *  Runs both an address and a timezone look-up for the given location.\n *  @private\n *\n *  @param {Object} location\n *         Location object.\n *  @param {Object} options\n *         Method options.\n *  @param {Function} callback\n *         Parent callback.\n */\nfunction fetchAddressAndTimezone(location, options, callback) {\n    let loc = utils.clone(location, { own: false });\n    if (!options.addressLookup && !options.timezone) {\n        return callback(null, loc);\n    }\n    function getTZ(cb) {\n        geolocator.getTimeZone(loc.coords, (err, timezone) => {\n            if (err) {\n                return cb(err, null);\n            }\n            delete timezone.timestamp;\n            loc.timezone = timezone;\n            loc.timestamp = utils.time(); // update timestamp\n            cb(null, loc);\n        });\n    }\n    if (options.addressLookup) {\n        geolocator.reverseGeocode(loc.coords, (err, result) => {\n            if (err) return callback(err, null);\n            loc = utils.extend({}, result, loc);\n            loc.address = result.address;\n            loc.timestamp = utils.time(); // update timestamp\n            if (!options.timezone) {\n                callback(err, loc);\n            } else {\n                getTZ(callback);\n            }\n        });\n    } else if (options.timezone) {\n        getTZ(callback);\n    } else {\n        callback(null, loc);\n    }\n}\n\n/**\n *  Gets the position with better accuracy.\n *  See https://github.com/gwilson/getAccurateCurrentPosition#background\n *  @private\n *\n *  @param {Object} options\n *         Locate options.\n *  @param {Function} onPositionReceived\n *         Success callback.\n *  @param {Function} onPositionError\n *         Error callback.\n */\nfunction locateAccurate(options, onPositionReceived, onPositionError) {\n    let loc, watcher;\n\n    function complete() {\n        if (!loc) {\n            onPositionError(new GeoError(GeoError.Code.POSITION_UNAVAILABLE));\n        } else {\n            onPositionReceived(loc);\n        }\n    }\n\n    watcher = geolocator.watch(options, (err, location) => {\n        if (err) {\n            return watcher.clear(() => {\n                onPositionError(err);\n            });\n        }\n        if (!loc || (location.coords.accuracy <= loc.coords.accuracy)) {\n            loc = location;\n        }\n        // ignore the first event if not the only result; for more accuracy.\n        if ((watcher.cycle > 1) && (loc.coords.accuracy <= options.desiredAccuracy)) {\n            watcher.clear(complete);\n        }\n    });\n    watcher.clear(options.timeout, complete);\n}\n\n// ---------------------------\n// INITIALIZE\n// ---------------------------\n\n/**\n *  @private\n *  @type {Object}\n */\ngeolocator._ = {\n    config: utils.extend({}, defaultConfig),\n    // Storage for global callbacks.\n    cb: {}\n};\n\n// setting default Geo-IP source, Wikimedia\ngeolocator.setGeoIPSource({\n    provider: 'wikimedia',\n    url: 'https://bits.wikimedia.org/geoiplookup',\n    callbackParam: null,\n    globalVar: 'Geo',\n    schema: {\n        ip: 'IP',\n        coords: {\n            latitude: 'lat',\n            longitude: 'lon'\n        },\n        address: {\n            city: 'city',\n            state: 'region',\n            stateCode: 'region',\n            postalCode: '',\n            countryCode: 'country',\n            country: 'country',\n            region: 'region'\n        }\n    }\n});\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexport default geolocator;\n\n// ---------------------------\n// ADDITIONAL DOCUMENTATION\n// ---------------------------\n\n/**\n *  Specifies the geographic location of the device. The location is expressed\n *  as a set of geographic coordinates together with information about heading\n *  and speed.\n *\n *  @typedef geolocator~Coordinates\n *  @type Object\n *\n *  @property {Number} latitude\n *         Specifies the latitude estimate in decimal degrees. The value\n *         range is [-90.00, +90.00].\n *  @property {Number} longitude\n *         Specifies the longitude estimate in decimal degrees. The value\n *         range is [-180.00, +180.00].\n *  @property {Number} altitude\n *         Specifies the altitude estimate in meters above the WGS 84\n *         ellipsoid.\n *  @property {Number} accuracy\n *         Specifies the accuracy of the latitude and longitude estimates in\n *         meters.\n *  @property {Number} altitudeAccuracy\n *         Specifies the accuracy of the altitude estimate in meters.\n *  @property {Number} heading\n *         Specifies the device's current direction of movement in degrees\n *         counting clockwise relative to true north.\n *  @property {Number} speed\n *         Specifies the device's current ground speed in meters per second.\n */\n\n/**\n *\tSpecifies the address of the fetched location. The address is expressed\n *\tas a set of political and locality components.\n *\n *  @typedef geolocator~Address\n *  @type Object\n *\n *  @property {String} commonName\n *         Indicates a point of interest, a premise or colloquial area name for\n *         the fetched location, if any.\n *  @property {String} streetNumber\n *         Indicates the precise street number of the fetched location, if any.\n *  @property {String} street\n *         Indicates the street name of the fetched location, if any.\n *  @property {String} route\n *         Indicates the route name of the fetched location, if any.\n *  @property {String} neighborhood\n *         Indicates the neighborhood name of the fetched location, if any.\n *  @property {String} town\n *         Indictes the town of the fetched location, if any.\n *  @property {String} city\n *         Indicates the city of the fetched location.\n *  @property {String} region\n *         Indicates the political region name of the fetched location, if any.\n *  @property {String} postalCode\n *         Indicates the postal code of the fetched location, if any.\n *  @property {String} state\n *         Indicates the state of the fetched location, if any.\n *  @property {String} stateCode\n *         Indicates the state code of the fetched location, if any.\n *  @property {String} country\n *         Indicates the national political entity of the fetched location.\n *  @property {String} countryCode\n *         Indicates the ISO alpha-2 country code of the fetched location.\n */\n\n/**\n *\tSpecifies time offset data for the fetched location on the surface of the\n *\tearth.\n *\n *  @typedef geolocator~TimeZone\n *  @type Object\n *\n *  @property {String} id\n *         The ID of the time zone, such as `\"America/Los_Angeles\"` or\n *         `\"Australia/Sydney\"`. These IDs are defined in the\n *         {@link http://www.iana.org/time-zones|IANA Time Zone Database},\n *         which is also available in searchable format in Wikipedia's\n *         {@link http://en.wikipedia.org/wiki/List_of_tz_database_time_zones|List of tz database time zones}.\n *  @property {String} name\n *         The long form name of the time zone. This field will be localized if\n *         the Geolocator `language` is configured. e.g. `\"Pacific Daylight Time\"`\n *         or `\"Australian Eastern Daylight Time\"`.\n *  @property {String} abbr\n *         The abbreviation of the time zone.\n *  @property {Number} dstOffset\n *         The offset for daylight-savings time in seconds. This will be zero\n *         if the time zone is not in Daylight Savings Time during the specified\n *         timestamp.\n *  @property {Number} rawOffset\n *         The offset from UTC (in seconds) for the given location. This does\n *         not take into effect daylight savings.\n */\n\n/**\n *\tProvides references to the components of a created Google Maps `Map` and\n *\tthe containing DOM element.\n *\n *  @typedef geolocator~MapData\n *  @type Object\n *\n *  @property {HTMLElement} element\n *         DOM element which a (Google) map is created within.\n *  @property {google.maps.Map} instance\n *         Instance of a Google Maps `Map` object.\n *  @property {google.maps.Marker} marker\n *         Instance of a Google Maps `Marker` object, if any.\n *  @property {google.maps.InfoWindow} infoWindow\n *         Instance of a Google Maps `InfoWindow` object, if any.\n *  @property {Object} options\n *         Arbitrary object of applied map options.\n */\n\n/**\n *\tSpecifies geographic coordinates, address and time zone information\n *\tfor the fetched location.\n *\n *  This result object is passed to the callbacks of the corresponding\n *  asynchronous Geolocator methods, as the second argument. The contents of\n *  this object will differ for various Geolocator methods, depending on the\n *  configured method options.\n *\n *  @typedef geolocator~Location\n *  @type Object\n *\n *  @property {Coordinates} coords\n *         Specifies the geographic location of the device. The location is\n *         expressed as a set of geographic coordinates together with\n *         information about heading and speed.\n *         See {@link #geolocator~Coordinates|`geolocator~Coordinates` type}\n *         for details.\n *  @property {Address} address\n *         Specifies the address of the fetched location. The address is\n *         expressed as a set of political and locality components.\n *         This property might be `undefined` if `addressLookup` option is not\n *         enabled for the corresponding method.\n *         See {@link #geolocator~Address|`geolocator~Address` type}\n *         for details.\n *  @property {String} formattedAddress\n *         The human-readable address of this location. Often this address is\n *         equivalent to the \"postal address,\" which sometimes differs from\n *         country to country.\n *  @property {Boolean} targetReached\n *         Specifies whether the defined target coordinates is reached.\n *         This property is only available for\n *         {@link #geolocator.watch|`geolocator.watch()`} method when `target`\n *         option is defined.\n *  @property {String} type\n *         Type of the location. See\n *         {@link #geolcoator.LocationType|`geolcoator.LocationType` enumeration}\n *         for details.\n *  @property {String} placeId\n *         A unique identifier that can be used with other Google APIs.\n *  @property {String} flag\n *         URL of the country flag image, in SVG format. This property exists\n *         only if address information is available.\n *  @property {TimeZone} timezone\n *         Specifies time offset data for the fetched location on the surface of\n *         the earth. See {@link #geolocator~TimeZone|`geolocator~TimeZone` type}\n *         for details.\n *  @property {MapData} map\n *         Provides references to the components of a created Google Maps `Map`\n *         and the containing DOM element. See\n *         {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n *  @property {Number} timestamp\n *         Specifies the time when the location information was retrieved and\n *         the `Location` object created.\n */\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/geolocator.js\n **/","\nlet _toString = Object.prototype.toString;\n\n/**\n * Simple utility methods; internally used within Geolocator core;\n * made publically accessible.\n * @type {Object}\n * @readonly\n *\n * @license MIT\n * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nconst utils = {\n\n    noop() {},\n\n    // ---------------------------\n    // Validation\n    // ---------------------------\n\n    /**\n     * Checks if the type of the given value is `String`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isString(value) {\n        return typeof value === 'string';\n    },\n\n    isStringSet(value) {\n        return typeof value === 'string' && value.trim().length > 0;\n    },\n\n    /**\n     * Checks if the type of the given value is `Number`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isNumber(value) {\n        return typeof value === 'number';\n    },\n\n    /**\n     * Checks if the type of the given value is an `Object` or `Function`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isObject(value) {\n        let type = typeof value;\n        return Boolean(value) && (type === 'object' || type === 'function');\n    },\n\n    /**\n     * Checks if the type of the given value is `Function`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isFunction(value) {\n        return typeof value === 'function';\n    },\n\n    /**\n     * Checks if the type of the given value is `Array`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isArray(value) {\n        return Boolean(value) && _toString.call(value) === '[object Array]';\n    },\n\n    /**\n     * Checks if the given value is a plain `Object`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isPlainObject(value) {\n        return Boolean(value)\n            && typeof value === 'object'\n            && _toString.call(value) === '[object Object]';\n    },\n\n    /**\n     * Checks if the given value is a `Date`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isDate(value) {\n        return Boolean(value) && _toString.call(value) === '[object Date]';\n    },\n\n    /**\n     * Checks if the given object is a DOM element.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isElement(object) {\n        if (!object) return false;\n        return object instanceof HTMLElement\n            || (typeof object === 'object' && object.nodeType === 1);\n    },\n\n    /**\n     * Checks if the given object is a DOM node.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isNode(object) {\n        if (!object) return false;\n        return object instanceof Node\n            || (typeof object === 'object' && typeof object.nodeType === 'number');\n    },\n\n    /**\n     * Checks if the given object is a jQuery instance.\n     * This will still return `false` if the jQuery instance has no items.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isJQueryObject(object) {\n        if (!object) return false;\n        return ('jQuery' in window && object instanceof window.jQuery && Boolean(object[0]));\n            // http://api.jquery.com/jquery-2/\n            // || (typeof object === 'object' && Boolean(object.jquery));\n    },\n\n    /**\n     * Checks if the type of the given value is an HTML5 `PositionError`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isPositionError(value) {\n        return Boolean(value) && _toString.call(value) === '[object PositionError]';\n    },\n\n    /**\n     * Checks if the given value is an instance of `Error` or HTML5 `PositionError`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isError(value) {\n        return (value instanceof Error) || utils.isPositionError(value);\n    },\n\n    // ---------------------------\n    // String\n    // ---------------------------\n\n    /**\n     * Removes the query string portion from the given URL string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    removeQuery(str) {\n        return str.replace(/\\?.*$/, '');\n    },\n\n    /**\n     * Removes the protocol portion from the given URL string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    removeProtocol(str) {\n        return str.replace(/^(.*:)?\\/\\//, '');\n    },\n\n    /**\n     * Sets the protocol of the given URL.\n     * @memberof utils\n     *\n     * @param {String} url - The URL to be modified.\n     * @param {Boolean} https - Optional. Default: `undefined`\n     * Specifies whether to set the protocol to HTTPS.\n     * If omitted, current page protocol will be used.\n     * @returns {String} - The modified URL string.\n     */\n    setProtocol(url, https) {\n        let p;\n        if (https === undefined || https === null) {\n            p = window.location.protocol;\n        } else {\n            p = https ? 'https:' : 'http:';\n        }\n        url = utils.removeProtocol(url);\n        return `${p}//${url}`;\n    },\n\n    /**\n     * Removes both the leading and trailing dots from the given string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    trimDots(str) {\n        return str.replace(/^\\.+?(.*?)\\.+?$/g, '$1');\n    },\n\n    /**\n     * URL-Encodes the given string. Note that the encoding is done Google's\n     * way; that is, spaces are replaced with `+` instead of `%20`.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the encoded string.\n     */\n    encodeURI(str) {\n        return encodeURIComponent(str).replace(/%20/g, '+');\n    },\n\n    /**\n     * URL-Decodes the given string. This is the reverse of `utils.encodeURI()`;\n     * so pluses (`+`) are replaced with spaces.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the decoded string.\n     */\n    decodeURI(str) {\n        return decodeURIComponent(str.replace(/\\+/g, '%20'));\n    },\n\n    /**\n     * Converts the given value to string.\n     * null and undefined converts to empty string.\n     * If value is a function, it's native `toString()` method is used.\n     * Otherwise, value is coerced.\n     * @memberof utils\n     *\n     * @param {*} value - String to be converted.\n     * @returns {String} - Returns the result string.\n     */\n    toString(value) {\n        if (value === null || value === undefined) return '';\n        if (value.toString && utils.isFunction(value.toString)) {\n            return value.toString();\n        }\n        return String(value);\n    },\n\n    /**\n     * Generates a random string with the number of characters.\n     * @memberof utils\n     *\n     * @param {Number} len - Optional. Default: `1`.\n     * Length of the string.\n     * @returns {String} - Returns a random string.\n     */\n    randomString(len) {\n        if (!len || !utils.isNumber(len)) len = 1;\n        len = -Math.abs(len);\n        return Math.random().toString(36).slice(len);\n    },\n\n    /**\n     * Gets the abbreviation of the given phrase.\n     * @memberof utils\n     *\n     * @param {String} str - String to abbreviate.\n     * @param {Object} options - Abbreviation options.\n     *     @param {Boolean} options.upper - Whether to convert to upper-case.\n     *     @param {Boolean} options.dots - Whether to add dots after each abbreviation.\n     *\n     * @returns {String} - Returns the abbreviation of the given phrase.\n     */\n    abbr(str, options) {\n        options = utils.extend({\n            upper: true,\n            dots: true\n        }, options);\n        let d = options.dots ? '.' : '',\n            s = str.match(/(\\b\\w)/gi).join(d) + d;\n        return options.upper ? s.toUpperCase() : s;\n    },\n\n    /**\n     * Builds URI parameters from the given object.\n     * Note: This does not iterate deep objects.\n     * @memberof utils\n     *\n     * @param {Object} obj - Object to be processed.\n     * @param {Object} options - Parameterize options.\n     *     @param {Boolean} options.encode - Optional. Default: `true`.\n     *     Whether to encode URI components.\n     *     @param {String} options.operator - Optional. Default: `\"=\"`.\n     *     @param {String} options.separator - Optional. Default: `\"&\"`.\n     *     @param {Array} options.include - Optional. Default: `undefined`.\n     *     Keys to be included in the output params. If defined,\n     *     `options.exclude` is ignored.\n     *     @param {Array} options.exclude - Optional. Default: `undefined`.\n     *     Keys to be excluded from the output params.\n     *\n     * @returns {String} - URI parameters string.\n     */\n    params(obj, options) {\n        if (!utils.isPlainObject(obj) || Object.keys(obj).length === 0) {\n            return '';\n        }\n\n        options = utils.extend({\n            encode: true,\n            operator: '=',\n            separator: '&',\n            include: undefined,\n            exclude: undefined\n        }, options);\n\n        let params = [],\n            inc = utils.isArray(options.include) ? options.include : null,\n            exc = !inc && utils.isArray(options.exclude) ? options.exclude : null;\n        utils.forIn(obj, (value, key) => {\n            if ((!inc || inc.indexOf(key) >= 0)\n                    && (!exc || exc.indexOf(key) < 0)) {\n                let v = utils.toString(value);\n                v = options.encode ? utils.encodeURI(v) : v;\n                let k = options.encode ? utils.encodeURI(key) : key;\n                params.push(k + options.operator + v);\n            }\n        });\n\n        return params.join(options.separator);\n    },\n\n    /**\n     * Gets the object from the given object notation string.\n     * @private\n     *\n     * @param {String} notation - Object notation.\n     * @returns {*} - Any existing object.\n     */\n    notateGlobalObj(notation) {\n        notation = utils.trimDots(notation);\n        let levels = notation.split('.'),\n            o = window;\n        if (levels[0] === 'window' || levels[0] === 'document') {\n            levels.shift();\n        }\n        levels.forEach(note => {\n            o = o[note];\n        });\n        return o;\n    },\n\n    // ---------------------------\n    // Object\n    // ---------------------------\n\n    /**\n     * Iterates over own properties of an object invoking a callback for each\n     * property.\n     * @memberof utils\n     *\n     * @param {Object} obj - Object to be processed.\n     * @param {Function} callback - Callback function with the following\n     * signature: `function (value, key, object) { ... }`.\n     * Explicitly returning `false` will exit the iteration early.\n     * @returns {void}\n     */\n    forIn(obj, callback) {\n        let k;\n        for (k in obj) {\n            // if (obj.hasOwnProperty(k)) {} // Do this inside callback if needed.\n            if (callback(obj[k], k, obj) === false) break;\n        }\n    },\n\n    /**\n     * Extends the given object with the specified sources.\n     * Right most source overwrites the previous.\n     * NOTE: This is not a full implementation. Use with caution.\n     * @memberof utils\n     *\n     * @param {Object} destination - Destionation Object that will be extended\n     * and holds the default values.\n     * @param {...Object} sources - Source objects to be merged.\n     * @returns {Object} - Returns the extended object.\n     */\n    extend(destination, ...sources) {\n        if (!utils.isObject(destination)) return {};\n        let key, value;\n        sources.forEach(source => {\n            for (key in source) { // eslint-disable-line\n                value = source[key];\n                if (utils.isArray(value)) {\n                    destination[key] = value.concat();\n                } else if (utils.isDate(value)) {\n                    destination[key] = new Date(value);\n                } else if (utils.isObject(value)) {\n                    destination[key] = utils.extend({}, value);\n                } else {\n                    destination[key] = value;\n                }\n            }\n        });\n        return destination;\n    },\n\n    /**\n     * Clones the given object.\n     * NOTE: This is not a full implementation. Use with caution.\n     * @memberof utils\n     *\n     * @param {Object} obj - Target Object to be cloned.\n     * @param {Object|Array} options - Optional. Clone options or array of keys\n     * to be cloned.\n     *     @param {Array} options.keys - Optional. Default: `undefined`.\n     *     Keys of the properties to be cloned.\n     *     @param {Boolean} options.own - Optional. Default: `true`.\n     *     Whether to clone own properties only. This is only effective if\n     *     `keys` is not defined.\n     * @returns {Object} - Returns the cloned object.\n     */\n    clone(obj, options) {\n        if (!obj) return {};\n\n        if (utils.isArray(options)) {\n            options = { keys: options };\n        }\n        options = utils.extend({\n            keys: null,\n            own: true\n        }, options);\n\n        let include,\n            cloned = {};\n\n        utils.forIn(obj, (value, key) => {\n            include = options.keys\n                ? options.keys.indexOf(key) >= 0\n                : (options.own && obj.hasOwnProperty(key)) || !options.own;\n            if (include) {\n                if (utils.isObject(value)) {\n                    cloned[key] = utils.clone(value, options);\n                } else {\n                    cloned[key] = value;\n                }\n            }\n        });\n        return cloned;\n    },\n\n    /**\n     *  Maps the values of the given object to a schema to re-structure a new\n     *  object.\n     *  @memberof utils\n     *\n     *  @param {Object} obj - Original object to be mapped.\n     *  @param {Object} schema - Schema to be used to map the object.\n     *  @returns {Object} - Mapped object.\n     */\n    mapToSchema(obj, schema) {\n        let mapped = {};\n        utils.forIn(schema, (value, key) => {\n            if (utils.isPlainObject(value)) {\n                // TODO: dot notation in schema values???\n                mapped[key] = utils.mapToSchema(obj, value);\n            } else {\n                mapped[key] = obj[value];\n            }\n        });\n        return mapped;\n    },\n\n    // ---------------------------\n    // Misc\n    // ---------------------------\n\n    /**\n     * Safely parses the given JSON `String` into an `Object`.\n     * The only difference from `JSON.parse()` is that this method does not\n     * throw for invalid input. Instead, returns `null`.\n     * @memberof utils\n     *\n     * @param {String} str - JSON string to be parsed\n     * @returns {Object|null} - Returns the parsed `Object` or `null` if the\n     * input is invalid.\n     */\n    safeJsonParse(str) {\n        let o = null;\n        try {\n            o = JSON.parse(str);\n        } catch (e) {}\n        return o;\n    },\n\n    /**\n     * Gets a timestamp that is seconds or milliseconds since midnight,\n     * January 1, 1970 UTC.\n     * @memberof utils\n     *\n     * @param {Boolean} seconds - Optional. Default: `false`.\n     * Specifies whether seconds should be returned instead of milliseconds.\n     * @returns {Number} - Returns seconds or milliseconds since midnight,\n     * January 1, 1970 UTC.\n     */\n    time(seconds) {\n        let ts = Date.now();\n        return seconds ? parseInt(ts / 1000, 10) : ts;\n    }\n\n};\n\nexport default utils;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/utils.js\n **/","import utils from './utils';\n\n/**\n * Utility for making `XMLHttpRequest` and `JSONP` requests.\n *\n * @license MIT\n * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nclass fetch {\n\n    // https://html.spec.whatwg.org/multipage/scripting.html#script\n\n    /**\n     * Makes a JSONP (GET) request by injecting a script tag in the browser.\n     * Note that using JSONP has some security implications. As JSONP is really\n     * javascript, it can do everything else javascript can do, so you need to\n     * trust the provider of the JSONP data.\n     * @see https://en.wikipedia.org/wiki/JSONP\n     * @memberof fetch\n     *\n     * @param {Object|String} options - Required. Either the URL string which\n     *     will set other options to defaults or an options object with the\n     *     following properties.\n     *     @param {String} options.url - Required. Source URL to be called.\n     *     @param {String} options.type - Optional. Default: `undefined`.\n     *     The MIME type that identifies the scripting language of the code\n     *     referenced within the script element. e.g. `\"text/javascript\"`\n     *     @param {String} options.charset - Optional. Default: `undefined`.\n     *     Indicates the character encoding of the external resource. e.g. `\"utf-8\"`.\n     *     @param {Boolean} options.async - Optional. Default: `true`.\n     *     Indicates whether or not to perform the operation asynchronously.\n     *     See {@link http://caniuse.com/#feat=script-async|browser support}.\n     *     @param {Boolean} options.defer - Optional. Default: `false`.\n     *     Indicates whether the script should be executed when the page has\n     *     finished parsing. See {@link http://caniuse.com/#feat=script-defer|browser support}.\n     *     @param {String} options.crossorigin - Optional. Default: `undefined`.\n     *     Indicates the CORS setting for the script element being injected.\n     *     Note that this attribute is not widely supported.\n     *     Valid values: `\"anonymous\"`, `\"use-credentials\"`.\n     *     See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes|CORS settings}.\n     *     @param {Number} options.timeout - Optional. Default: `0` (no timeout).\n     *     The number of milliseconds a request can take before automatically\n     *     being terminated.\n     *     @param {Boolean} options.clean - Optional. Default: `false`.\n     *     Whether to remove the loaded script from DOM when the operation ends.\n     *     Note that the initial source might load additional sources which are\n     *     not deteceted or removed. Only the initial source is removed.\n     *     @param {Object} options.params - Optional. Default: `undefined`.\n     *     Optional query parameters to be appended at the end of the URL.\n     *     e.g. `{ key: \"MY-KEY\" }`\n     *     You can also include the JSONP callback name parameter here but\n     *     if you want the object to be passed to the callback argument of this\n     *     method, use `options.callbackParam` to set the callback parameter.\n     *     @param {String} options.callbackParam - Optional. Default: `undefined`.\n     *     If the endpoint supports JSONP callbacks, you can set the callback\n     *     parameter with this setting. This will enable a second `obj` argument\n     *     in the callback of this method which is useful if the JSONP source\n     *     invokes the callback with an argument.\n     *     @param {String} options.rootName - Optional. Default: `undefined`.\n     *     The name (or notation) of the object that the generated JSONP\n     *     callback function should be assigned to. By default, this is the\n     *     `window` object but you can set this to a custom object notation;\n     *     for example, to prevent global namespace polution. Note that this\n     *     root object has to be globally accessible for this to work.\n     *     e.g. `\"window.myObject\"` (as string)\n     * @param {Function} callback - Optional. The callback function that will be\n     * executed when the script is loaded. This callback has the following\n     * signature: `function (err, obj) { ... }`. Note that the second argument\n     * `obj` will always be `undefined` if the source endpoint does not support\n     * JSONP callbacks or a callback param is not set explicitly via\n     * `options.callbackParam` (or if the source does not invoke the jsonp with an\n     * argument). However, the function will always execute when the script\n     * loads or an error occurs.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var opts1 = {\n     * \turl: 'some/api',\n     * \tcallbackParam: 'jsonCallback',\n     * \tparams: { key: 'MY-KEY' }\n     * };\n     * // This will load the following source:\n     * // some/api?jsonCallback={auto-generated-fn-name}&key=MY-KEY\n     * fetch.jsonp(opts1, function (err, obj) {\n     * \tconsole.log(obj); // some object\n     * });\n     *\n     * var opts2 = {\n     * \turl: 'some/api',\n     * \tparams: {\n     * \t\tkey: 'MY-KEY',\n     * \t\tjsonCallback: 'my-fn-name'\n     * \t}\n     * };\n     * // This will load the following source:\n     * // some/api?jsonCallback=my-fn-name&key=MY-KEY\n     * fetch.jsonp(options, function (err, obj) {\n     * \tconsole.log(obj); // undefined\n     * \t// still executes, catch errors here\n     * });\n     * // JSON callback should be explicitly set.\n     * window['my-fn-name'] = function (obj) {\n     * \tconsole.log(obj); // some object\n     * };\n     */\n    static jsonp(options, callback) {\n        let timeout;\n\n        callback = utils.isFunction(callback)\n            ? callback\n            : utils.noop;\n\n        if (utils.isString(options)) {\n            options = { url: options };\n        }\n\n        if (utils.isPlainObject(options)) {\n            options = utils.extend({\n                // type: undefined,\n                async: true,\n                defer: false,\n                // crossorigin: undefined,\n                timeout: 0,\n                params: {},\n                // callbackParam: undefined,\n                // rootName: undefined,\n                clean: true\n            }, options);\n        } else {\n            return callback(new Error('No options or target URL is provided.'));\n        }\n\n        if (utils.isString(options.url) === false || options.url.trim() === '') {\n            return callback(new Error('No target URL is provided.'));\n        }\n\n        let script = document.createElement('script'),\n            cbParamSet = utils.isString(options.callbackParam)\n                && options.callbackParam.trim() !== '',\n            cbFnName,\n            root,\n            rootNameSet = utils.isString(options.rootName)\n                && options.rootName !== 'window'\n                && options.rootName !== 'document'\n                && options.rootName.trim() !== '';\n\n        if (cbParamSet) {\n            cbFnName = '_jsonp_' + utils.randomString(10);\n            options.params[options.callbackParam] = rootNameSet\n                ? `${options.rootName}.${cbFnName}`\n                : cbFnName;\n        }\n        let query = utils.params(options.params) || '',\n            qMark = options.url.indexOf('?') >= 0 ? '&' : '?',\n            url = query ? `${options.url}${qMark}${query}` : options.url;\n        // console.log(url);\n\n        function execCb(err, timeUp, obj) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            if ((timeUp || options.clean) && script.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n            // delete the jsonp callback function\n            if (rootNameSet) {\n                delete root[cbFnName];\n            }\n            callback(err, obj);\n        }\n\n        if (cbFnName) {\n            let fn = obj => {\n                execCb(null, false, obj);\n            };\n            root = rootNameSet\n                // ? window[options.rootName][cbFnName] = fn;\n                ? utils.notateGlobalObj(options.rootName) // if rootName is dot-notation.\n                : window;\n            root[cbFnName] = fn;\n        } else if (script.readyState) { // IE < 11\n            script.onreadystatechange = () => {\n                if (script.readyState === 'loaded'\n                        || script.readyState === 'complete') {\n                    script.onreadystatechange = null;\n                    execCb(null);\n                }\n            };\n        } else { // IE 11+\n            script.onload = () => {\n                execCb(null);\n            };\n        }\n\n        script.onerror = error => {\n            let errMsg = 'Could not load source at ' + utils.removeQuery(options.url);\n            if (error) {\n                errMsg += '\\n' + (error.message || error);\n            }\n            execCb(new Error(errMsg));\n        };\n\n        if (options.type) {\n            script.type = options.type;\n        }\n        if (options.charset) {\n            script.charset = options.charset;\n        }\n        if (options.async) {\n            script.async = true;\n        }\n        if (options.defer) {\n            script.defer = true;\n        }\n        if (options.crossorigin) {\n            script.crossorigin = options.crossorigin;\n        }\n\n        script.src = url;\n        document.getElementsByTagName('head')[0].appendChild(script);\n\n        // Timeout\n        if (utils.isNumber(options.timeout) && options.timeout > 0) {\n            timeout = setTimeout(() => {\n                script.src = '';\n                execCb(new Error('Operation timed out.'), true);\n            }, options.timeout);\n        }\n    }\n\n    /**\n     * Makes an XMLHttpRequest with the given parameters.\n     * Note that `\"Access-Control-Allow-Origin\"` header should be present on\n     * the requested resource. Otherwise, the request will not be allowed.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}.\n     * @memberof fetch\n     *\n     * @param {Object|String} options - Required. Either the URL string which\n     *     will set other options to defaults or the full options object.\n     *     @param {String} options.url - Required. Target URL to be called.\n     *     @param {String} options.method - Default: `\"GET\"`. HTTP method.\n     *     @param {*} options.data - Optional. Default: `undefined`.\n     *     Data to be sent with the request, if the HTTP method is set to \"POST\".\n     *     @param {Number} options.timeout - Optional. Default: `0` (no timeout).\n     *     The number of milliseconds a request can take before automatically\n     *     being terminated.\n     *     @param {Boolean} options.withCredentials - Optional. Default: `false`.\n     *     Indicates whether or not cross-site Access-Control requests should\n     *     be made using credentials such as cookies or authorization headers.\n     *     @param {Boolean} options.async - Optional. Default: `true`.\n     *     Indicating whether or not to perform the operation asynchronously.\n     *     If this value is false, the `send()` method does not return until\n     *     the response is received. If `true`, notification of a completed\n     *     transaction is provided using event listeners. This must be `true`\n     *     if the multipart attribute is `true`, or an exception will be thrown.\n     *     @param {String} options.mimeType - Optional. Default: `undefined`.\n     *     If set, overrides the MIME type returned by the server. This may be\n     *     used, for example, to force a stream to be treated and parsed as\n     *     `text/xml`, even if the server does not report it as such.\n     *     @param {Object} options.headers - Optional. Default: `undefined`.\n     *     Sets the HTTP request headers. Each key should be a header name\n     *     with a value. e.g. `{ 'Content-Length': 50 }`. For security reasons,\n     *     some headers cannot be set and can only be controlled by the user agent.\n     *     @param {String} options.username - Optional. Default: `\"\"`.\n     *     User name to use for authentication purposes.\n     *     @param {String} options.password - Optional. Default: `\"\"`.\n     *     Password to use for authentication purposes.\n     * @param {Function} callback - Optional. The callback function in the\n     *     following signature: `function (err, xhr) { ... }`\n     *     Note that `xhr` object is always passed regardless of an error.\n     *\n     * @returns {void}\n     */\n    static xhr(options, callback) {\n        let xhr, err;\n\n        if ('XMLHttpRequest' in window) {\n            xhr = new XMLHttpRequest();\n        } else {\n            throw new Error('XMLHttpRequest is not supported!');\n        }\n\n        let hasCallback = utils.isFunction(callback);\n        callback = hasCallback\n            ? callback\n            : utils.noop;\n\n        if (utils.isString(options)) {\n            options = { url: options };\n        }\n\n        if (utils.isPlainObject(options)) {\n            options = utils.extend({\n                method: 'GET',\n                data: undefined,\n                async: true,\n                timeout: 0, // no timeout\n                withCredentials: false,\n                mimeType: undefined,\n                username: '',\n                password: ''\n            }, options);\n        } else {\n            callback(new Error('No options or target URL is provided.'));\n        }\n\n        if (utils.isString(options.url) === false) {\n            callback(new Error('No target URL is provided.'));\n        }\n\n        options.username = String(options.username);\n        options.password = String(options.password);\n        options.method = options.method.toUpperCase();\n        if (options.method !== 'POST' && options.method !== 'PUT') {\n            options.data = undefined;\n        }\n        // console.log(JSON.stringify(options));\n\n        if (hasCallback) {\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === fetch.XHR_READY_STATE.DONE) {\n                    if (xhr.status === 200) {\n                        callback(null, xhr);\n                    } else {\n                        // let response = utils.safeJsonParse(xhr.responseText);\n                        // if (response && response.error)\n                        let crossDomain = xhr.status === 0\n                            ? '. Make sure you have permission if this is a cross-domain request.'\n                            : '';\n                        err = new Error(`The request returned status: ${xhr.status}${crossDomain}`);\n                        // console.log(xhr);\n                        callback(err, xhr);\n                    }\n                }\n            };\n\n            if (utils.isNumber(options.timeout) && options.timeout > 0) {\n                xhr.timeout = options.timeout;\n                xhr.ontimeout = () => {\n                    // xhr.abort();\n                    err = new Error('The request had timed out.');\n                    callback(err, xhr);\n                };\n            }\n        }\n        // console.log(options);\n        xhr.open(options.method, options.url, options.async, options.username, options.password);\n\n        // xhr.setRequestHeader() method should b called œafter open(), but\n        // before send().\n        if (utils.isPlainObject(options.headers)) {\n            Object.keys(options.headers).forEach(key => {\n                let value = options.headers[key];\n                xhr.setRequestHeader(key, value);\n            });\n        }\n\n        // xhr.overrideMimeType() method must be called before send().\n        if (options.mimeType) {\n            xhr.overrideMimeType(options.mimeType);\n        }\n\n        xhr.send(options.data);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"GET\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options - Required. Either the URL string which\n     * will set other options to defaults or the full options object.\n     * See `fetch.xhr()` method options for details.\n     * @param {Function} callback - Optional. The callback function in the\n     * following signature: `function (err, xhr) { ... }`\n     * Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static get(options, callback) {\n        return fetch.xhr(options, callback);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"POST\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options - Required. Either the URL string which\n     * will set other options to defaults or the full options object.\n     * See `fetch.xhr()` method options for details.\n     * @param {Function} callback - Optional. The callback function in the\n     * following signature: `function (err, xhr) { ... }`\n     * Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static post(options, callback) {\n        return _xhr('POST', options, callback);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"PUT\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options - Required. Either the URL string which\n     * will set other options to defaults or the full options object.\n     * See `fetch.xhr()` method options for details.\n     * @param {Function} callback - Optional. The callback function in the\n     * following signature: `function (err, xhr) { ... }`\n     * Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static put(options, callback) {\n        return _xhr('PUT', options, callback);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"DELETE\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options - Required. Either the URL string which\n     * will set other options to defaults or the full options object.\n     * See `fetch.xhr()` method options for details.\n     * @param {Function} callback - Optional. The callback function in the\n     * following signature: `function (err, xhr) { ... }`\n     * Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static delete(options, callback) {\n        return _xhr('DELETE', options, callback);\n    }\n}\n\n/**\n *  @private\n */\nfunction _xhr(method, options, callback) {\n    options = utils.isString(options)\n        ? { url: options }\n        : options || {};\n    options.method = method;\n    return fetch.xhr(options, callback);\n}\n\n/**\n * Enumerates `XMLHttpRequest` ready states.\n * Not to be confused with `script.readyState`.\n * @memberof fetch\n *\n * @enum {Number}\n */\nfetch.XHR_READY_STATE = {\n    /**\n     * `xhr.open()` has not been called yet.\n     * @type {Number}\n     */\n    UNSENT: 0,\n    /**\n     * `xhr.send()` has been called.\n     * @type {Number}\n     */\n    OPENED: 1,\n    /**\n     * `xhr.send()` has been called, and headers and status are available.\n     * @type {Number}\n     */\n    HEADERS_RECEIVED: 2,\n    /**\n     * Downloading; responseText holds partial data.\n     * @type {Number}\n     */\n    LOADING: 3,\n    /**\n     * The operation is complete.\n     * @type {Number}\n     */\n    DONE: 4\n};\n\n// aliases\n// fetch.script = fetch.jsonp;\n// fetch.ajax = fetch.xhr;\n\nexport default fetch;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/fetch.js\n **/","import utils from '../lib/utils';\nimport fetch from '../lib/fetch';\nimport enums from './enums';\nimport GeoError from './geo.error';\n\n/**\n *  Helper methods.\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n *  @type {Object}\n *  @private\n */\nconst geoHelper = {\n\n    toGoogleCoords(coords) {\n        return {\n            lat: coords.lat || coords.latitude,\n            lng: coords.lng || coords.longitude\n        };\n    },\n\n    fromGoogleCoords(coords) {\n        return {\n            latitude: coords.latitude || coords.lat,\n            longitude: coords.longitude || coords.lng\n        };\n    },\n\n    // used for distance matrix origins and destinations\n    toPointList(arr) {\n        arr = utils.isArray(arr) ? arr : [arr];\n        return arr.map(o => {\n            return utils.isString(o) ? o : geoHelper.toGoogleCoords(o);\n        });\n    },\n\n    getGeocodeComps(comp) {\n        return {\n            route: comp.route,\n            locality: comp.locality,\n            administrative_area: comp.administrativeArea, // eslint-disable-line camelcase\n            postal_code: comp.postalCode, // eslint-disable-line camelcase\n            country: comp.country,\n            region: comp.region\n        };\n    },\n\n    // Geocode examples:\n    // address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=API_KEY\n    // address=Winnetka&bounds=34.172684,-118.604794|34.236144,-118.500938&key=API_KEY\n    // address=santa+cruz&components=country:ES&key=API_KEY\n    // components=administrative_area:TX|country:US&key=API_KEY\n    // Reverse Geocode examples:\n    // latlng=40.714224,-73.961452&key=API_KEY\n    // place_id=ChIJd8BlQ2BZwokRAFUEcm_qrcA&key=API_KEY\n    buildGeocodeParams(options, reverse) {\n        let params = [],\n            e = utils.encodeURI;\n\n        if (reverse) {\n            if (options.placeId) {\n                params.push(`place_id=${options.placeId}`);\n            } else if (options.latitude && options.longitude) {\n                params.push(`latlng=${options.latitude},${options.longitude}`);\n            }\n        } else {\n            if (options.address) {\n                params.push(`address=${e(options.address)}`);\n            }\n\n            let geoComps = geoHelper.getGeocodeComps(options);\n            geoComps = utils.params(geoComps, { operator: ':', separator: '|' });\n            params.push(`components=${geoComps}`);\n\n            let b = options.bounds;\n            if (utils.isArray(b) && b.length === 4) {\n                params.push(`bounds=${b[0]},${b[1]}|${b[2]},${b[3]}`);\n            } else if (utils.isPlainObject(b) && Object.keys(b).length === 4) {\n                params.push(`bounds=${b.southwestLat},${b.southwestLng}|${b.northeastLat},${b.northeastLng}`);\n            }\n        }\n\n        params.push(`language=${options.language}`);\n        params.push(`key=${options.key}`);\n        return params.join('&');\n    },\n\n    // See https://developers.google.com/maps/documentation/geocoding/intro\n    formatGeocodeResults(results) {\n        if (!utils.isArray(results) || results.length <= 0) {\n            return {\n                location: null,\n                address: null,\n                formattedAddress: '',\n                type: null, // locationType\n                placeId: ''\n            };\n        }\n\n        let i, c,\n            o = {},\n            data = results[0],\n            comps = data.address_components;\n\n        for (i = 0; i < comps.length; i += 1) {\n            c = comps[i];\n            if (c.types && c.types.length > 0) {\n                o[c.types[0]] = c.long_name;\n                o[c.types[0] + '_s'] = c.short_name;\n            }\n        }\n\n        let isUS = o.country_s === 'US',\n            geometry = data.geometry;\n        return {\n            coords: geometry && geometry.location ? {\n                latitude: geometry.location.lat,\n                longitude: geometry.location.lng\n            } : null,\n            address: {\n                commonName: o.point_of_interest\n                    || o.premise\n                    || o.subpremise\n                    || o.colloquial_area\n                    || '',\n                streetNumber: o.street_number || '',\n                street: o.administrative_area_level_4\n                    || o.administrative_area_level_3\n                    || o.route\n                    || '',\n                route: o.route || '',\n                neighborhood: o.neighborhood\n                    || o.administrative_area_level_5\n                    || o.administrative_area_level_4\n                    || '',\n                town: o.sublocality || o.administrative_area_level_2 || '',\n                city: o.locality || o.administrative_area_level_1 || '',\n                region: o.administrative_area_level_2\n                    || o.administrative_area_level_1\n                    || '',\n                postalCode: o.postal_code || '',\n                state: isUS\n                    ? (o.administrative_area_level_1 || '')\n                    : '',\n                stateCode: isUS\n                    ? (o.administrative_area_level_1_s || '')\n                    : '',\n                country: o.country || '',\n                countryCode: o.country_s || ''\n            },\n            formattedAddress: data.formatted_address,\n            type: geometry.location_type || '',\n            placeId: data.place_id,\n            timestamp: utils.time()\n        };\n    },\n\n    geocode(reverse, conf, options, callback) {\n        let opts = {};\n        if (utils.isString(options)) {\n            opts = {};\n            let prop = reverse ? 'placeId' : 'address';\n            opts[prop] = options;\n        } else if (utils.isPlainObject(options)) {\n            opts = options;\n        } else {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n        }\n\n        if (reverse) {\n            let coordsSet = utils.isNumber(options.latitude)\n                && utils.isNumber(options.longitude);\n            if (!utils.isString(options.placeId) && !coordsSet) {\n                throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n            }\n        }\n\n        opts = utils.extend({\n            key: conf.google.key || '',\n            language: conf.language || 'en',\n            raw: false\n        }, opts);\n\n        let query = geoHelper.buildGeocodeParams(opts, reverse),\n            url = utils.setProtocol(enums.URL.GOOGLE_GEOCODE, conf.https),\n            xhrOpts = {\n                url: `${url}?${query}`\n            };\n\n        fetch.xhr(xhrOpts, (err, xhr) => {\n            if (err) return callback(GeoError.create(err), null);\n\n            let response = utils.safeJsonParse(xhr.responseText),\n                gErr = GeoError.fromResponse(response);\n\n            if (gErr) return callback(gErr, null);\n\n            response = options.raw\n                ? response\n                : geoHelper.formatGeocodeResults(response.results);\n            callback(null, response);\n        });\n    },\n\n    // See https://developers.google.com/maps/documentation/distance-matrix/intro\n    // Raw Result Example:\n    // {\n    //    \"destination_addresses\" : [ \"San Francisco, CA, USA\", \"Victoria, BC, Canada\" ],\n    //    \"origin_addresses\" : [ \"Vancouver, BC, Canada\", \"Seattle, WA, USA\" ],\n    //    \"rows\" : [\n    //       {\n    //          \"elements\" : [\n    //             {\n    //                \"distance\" : { \"text\" : \"1,704 km\", \"value\" : 1704324 },\n    //                \"duration\" : { \"text\" : \"3 days 19 hours\", \"value\" : 327061\n    //                },\n    //                \"status\" : \"OK\"\n    //             },\n    //             {\n    //                \"distance\" : { \"text\" : \"138 km\", \"value\" : 138295 },\n    //                \"duration\" : { \"text\" : \"6 hours 44 mins\", \"value\" : 24236 },\n    //                \"status\" : \"OK\"\n    //             }\n    //          ]\n    //       },\n    //       {\n    //          \"elements\" : [\n    //             {\n    //                \"distance\" : { \"text\" : \"1,452 km\", \"value\" : 1451623 },\n    //                \"duration\" : { \"text\" : \"3 days 4 hours\", \"value\" : 275062 },\n    //                \"status\" : \"OK\"\n    //             },\n    //             {\n    //                \"distance\" : { \"text\" : \"146 km\", \"value\" : 146496 },\n    //                \"duration\" : { \"text\" : \"2 hours 52 mins\", \"value\" : 10324 },\n    //                \"status\" : \"OK\"\n    //             }\n    //          ]\n    //       }\n    //    ],\n    //    \"status\" : \"OK\"\n    // }\n    // Formatted to:\n\n    formatDistanceResults(results) {\n        if (!utils.isPlainObject(results)) {\n            return null;\n        }\n\n        let arr = [],\n            origins = results.originAddresses,\n            dests = results.destinationAddresses,\n            rows = results.rows;\n\n        // [\n        //     {\n        //          from: 'Vancouver, BC, Canada',\n        //          to: 'San Francisco, CA, USA',\n        //          distance: { value: 1704107, text: \"1,704 km\" },\n        //          duration: { value: 327025, text: \"3 days 19 hours\" },\n        //          fare: { currency: \"USD\", value: 6, text: \"$6.00\" }\n        //     },\n        //     ...\n        // ]\n\n        let e;\n        origins.forEach((origin, oIndex) => {\n            dests.forEach((dest, dIndex) => {\n                e = rows[oIndex].elements[dIndex];\n                arr.push({\n                    from: origin,\n                    to: dest,\n                    distance: e.distance,\n                    duration: e.duration,\n                    fare: e.fare,\n                    timestamp: utils.time()\n                });\n            });\n        });\n\n        return arr;\n    }\n\n};\n\nexport default geoHelper;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/geo.helper.js\n **/","/**\n * This file only includes partial documentation about `geolocator` enumerations.\n * Note that these enumerations are mostly an aggregation of\n * {@link https://developers.google.com/maps/documentation/javascript|Google Maps API} constants.\n *\n * @private\n * @readonly\n */\nconst enums = Object.freeze({\n    /**\n     * Enumerates API endpoints used within Geolocator core.\n     *\n     * @enum {String}\n     * @readonly\n     * @private\n     */\n    URL: {\n        /**\n         *  Public IP retrieval (free) service.\n         *  @type {String}\n         *  @private\n         */\n        IP: '//api.ipify.org',\n        /**\n         *  Country SVG flags.\n         *  e.g. <url>/tr.svg for Turkey flag.\n         *  @type {String}\n         *  @private\n         */\n        FLAG: '//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/',\n        /**\n         * Google Maps API bootstrap endpoint that loads all of the main\n         * Javascript objects and symbols for use in the Maps API.\n         * Some Maps API features are also available in self-contained\n         * libraries which are not loaded unless you specifically request them.\n         * See {@link https://developers.google.com/maps/documentation/javascript/libraries|details}.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_MAPS_API: '//maps.googleapis.com/maps/api/js',\n        /**\n         * Google Geolocation API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_GEOLOCATION: '//www.googleapis.com/geolocation/v1/geolocate',\n        /**\n         * Google Geocode API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_GEOCODE: '//maps.googleapis.com/maps/api/geocode/json',\n        /**\n         * Google TimeZone API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_TIMEZONE: '//maps.googleapis.com/maps/api/timezone/json',\n        /**\n         * Google Distance Matrix API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_DISTANCE_MATRIX: '//maps.googleapis.com/maps/api/distancematrix/json'\n    },\n    /**\n     * Enumerates Google map types.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    MapTypeId: {\n        /**\n         * Map type that displays a transparent layer of major streets on\n         * satellite images.\n         * @type {String}\n         */\n        HYBRID: 'hybrid',\n        /**\n         * Map type that displays a normal street map.\n         * @type {String}\n         */\n        ROADMAP: 'roadmap',\n        /**\n         * Map type that displays satellite images.\n         * @type {String}\n         */\n        SATELLITE: 'satellite',\n        /**\n         * Map type displays maps with physical features such as terrain and\n         * vegetation.\n         * @type {String}\n         */\n        TERRAIN: 'terrain'\n    },\n    /**\n     * Enumerates Google location types.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    LocationType: {\n        /**\n         * Indicates that the returned result is a precise geocode for which\n         * we have location information accurate down to street address\n         * precision.\n         * @type {String}\n         */\n        ROOFTOP: 'ROOFTOP',\n        /**\n         * Indicates that the returned result reflects an approximation\n         * (usually on a road) interpolated between two precise points (such as\n         * intersections). Interpolated results are generally returned when\n         * rooftop geocodes are unavailable for a street address.\n         * @type {String}\n         */\n        RANGE_INTERPOLATED: 'RANGE_INTERPOLATED',\n        /**\n         * Indicates that the returned result is the geometric center of a\n         * result such as a polyline (for example, a street) or polygon\n         * (region).\n         * @type {String}\n         */\n        GEOMETRIC_CENTER: 'GEOMETRIC_CENTER',\n        /**\n         * Indicates that the returned result is approximate.\n         * @type {String}\n         */\n        APPROXIMATE: 'APPROXIMATE'\n    },\n    /**\n     * Enumerates Google travel modes.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    TravelMode: {\n        /**\n         * Indicates distance calculation using the road network.\n         * @type {String}\n         */\n        DRIVING: 'DRIVING',\n        /**\n         * Requests distance calculation for walking via pedestrian paths &\n         * sidewalks (where available).\n         * @type {String}\n         */\n        WALKING: 'WALKING',\n        /**\n         * Requests distance calculation for bicycling via bicycle paths &\n         * preferred streets (where available).\n         * @type {String}\n         */\n        BICYCLING: 'BICYCLING',\n        /**\n         * Requests distance calculation via public transit routes (where\n         * available). This value may only be specified if the request includes\n         * an API key or a Google Maps APIs Premium Plan client ID. If you set\n         * the mode to transit you can optionally specify either a\n         * `departureTime` or an `arrivalTime`. If neither time is specified,\n         * the `departureTime` defaults to now (that is, the departure time defaults\n         * to the current time). You can also optionally include a `transitMode`\n         * and/or a `transitRoutingPreference`.\n         * @type {String}\n         */\n        TRANSIT: 'TRANSIT'\n    },\n    // /**\n    //  * Enumerates Google route restrictions.\n    //  * @memberof! geolocator\n    //  *\n    //  * @enum {String}\n    //  * @readonly\n    //  */\n    // RouteRestriction: {\n    //     TOLLS: 'tolls',\n    //     HIGHWAYS: 'highways',\n    //     FERRIES: 'ferries',\n    //     INDOOR: 'indoor'\n    // },\n    /**\n     * Enumerates Google unit systems.\n     * @memberof! geolocator\n     *\n     * @enum {Number}\n     * @readonly\n     */\n    UnitSystem: {\n        /**\n         * Distances in kilometers and meters.\n         * @type {Number}\n         */\n        METRIC: 0,\n        /**\n         * Distances defined in miles and feet.\n         * @type {Number}\n         */\n        IMPERIAL: 1\n    },\n    /**\n     * Enumerates mobile radio types.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    RadioType: {\n        /**\n         * LTE (Long-Term Evolution) mobile radio type.\n         * @type {String}\n         */\n        LTE: 'lte',\n        /**\n         * GSM (Global System for Mobile Communications) mobile radio type.\n         * @type {String}\n         */\n        GSM: 'gsm',\n        /**\n         * CDMA (Code division multiple access) mobile radio access technology.\n         * @type {String}\n         */\n        CDMA: 'cdma',\n        /**\n         * Wideband CDMA mobile radio access technology.\n         * @type {String}\n         */\n        WCDMA: 'wcdma'\n    },\n    /**\n     * Enumerates formulas/algorithms for calculating the distance between two\n     * lat/lng points.\n     * @memberof! geolocator\n     *\n     * @readonly\n     * @enum {String}\n     *\n     * @todo {@link https://en.wikipedia.org/wiki/Vincenty%27s_formulae|Vincenty's Formula}\n     */\n    DistanceFormula: {\n        /**\n         * Haversine formula for calculating the distance between two lat/lng points\n         * by relating the sides and angles of spherical triangles.\n         * @see {@link http://en.wikipedia.org/wiki/Haversine_formula|Haversine_formula}.\n         * @type {String}\n         */\n        HAVERSINE: 'haversine',\n        /**\n         * Formula based on the Pythagoras Theorem for calculating the\n         * distance between two lat/lng points on a Equirectangular projection\n         * to account for curvature of the longitude lines.\n         * @see {@link https://en.wikipedia.org/wiki/Pythagorean_theorem|Pythagorean_theorem}\n         * @type {String}\n         */\n        PYTHAGOREAN: 'pythagorean'\n    }\n});\n\nexport default enums;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/enums.js\n **/","import utils from '../lib/utils';\n\n/**\n * Geolocator Error class that provides a common type of error object for the\n * various APIs implemented in Geolocator. All callbacks of Geolocator will\n * include an instance of this object as the first argument; if the\n * corresponding operation fails. Also all thrown errors will be an instance of\n * this object.\n *\n * This object can be publicly accessed via `geolocator.Error`.\n *\n * @extends Error\n */\nclass GeoError { // extends Error (doesn't work with transpilers)\n\n    /**\n     * Costructs a new instance of `GeoError`.\n     *\n     * @param {String} [code=\"UNKNOWN_ERROR\"]\n     *        Any valid Geolocator Error code.\n     *        See {@link #GeoError.Code|`GeoError.Code` enumeration} for\n     *        possible values.\n     * @param {String} [message]\n     *        Error message. If omitted, this will be set to `code`.\n     *\n     * @returns {GeoError}\n     *\n     * @example\n     * var GeoError = geolocator.Error,\n     *     error = new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n     * console.log(error instanceof GeoError); // true\n     */\n    constructor(code = GeoError.Code.UNKNOWN_ERROR, message) {\n        message = message || String(code);\n\n        /**\n         *  Gets the name of the Error object.\n         *  This always returns `\"GeoError\"`.\n         *  @name GeoError#name\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'GeoError' // this.constructor.name\n        });\n\n        /**\n         *  Gets the error code set for this instance.\n         *  This will return one of\n         *  {@link #GeoError.Code|`GeoError.Code` enumeration}.\n         *  @name GeoError#code\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'code', {\n            enumerable: false,\n            writable: true,\n            value: code\n        });\n\n        /**\n         *  Gets the error message set for this instance.\n         *  If no message is set, this will return the error code value.\n         *  @name GeoError#message\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            /**\n             *  Gets the error stack for this instance.\n             *  @name GeoError#stack\n             *  @type {String}\n             */\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n\n    /**\n     * Creates a new instance of `GeoError` from the given value.\n     *\n     * @param {*} [err]\n     *        Value to be transformed. This is used to determine the proper\n     *        error code for the created instance. If an `Error` or `Object` is\n     *        passed, its `message` property is checked if it matches any of the\n     *        valid error codes. If omitted or no match is found, error code\n     *        `GeoError.Code.UNKNOWN_ERROR` will be used as default.\n     *\n     * @returns {GeoError}\n     *\n     * @example\n     * var GeoError = geolocator.Error,\n     * \t   error = GeoError.create();\n     * console.log(error.code); // \"UNKNOWN_ERROR\"\n     * error = GeoError.create(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n     */\n    static create(err) {\n        if (err instanceof GeoError) {\n            return err;\n        }\n\n        if (utils.isPositionError(err) && err.code) {\n            switch (err.code) {\n                case 1:\n                    return new GeoError(GeoError.Code.PERMISSION_DENIED, err.message);\n                case 2:\n                    return new GeoError(GeoError.Code.POSITION_UNAVAILABLE, err.message);\n                case 3:\n                    return new GeoError(GeoError.Code.TIMEOUT, err.message);\n                default:\n                    return new GeoError(GeoError.Code.UNKNOWN_ERROR, err.message || '');\n            }\n        }\n\n        let code, msg;\n        if (typeof err === 'string') {\n            code = msg = err;\n        } else if (typeof err === 'object') {\n            code = err.code || err.message;\n            msg = err.message || err.code;\n        }\n        if (code && GeoError.isValidErrorCode(code)) {\n            return new GeoError(code, msg);\n        }\n\n        return new GeoError(GeoError.Code.UNKNOWN_ERROR, msg);\n    }\n\n    /**\n     * Creates a new instance of `GeoError` from the given response object.\n     * Since Geolocator implements various Google APIs, we might receive\n     * responses if different structures. For example, some APIs return a\n     * response object with a `status:String` property (such as the TimeZone\n     * API) and some return responses with an `error:Object` property. This\n     * method will determine the correct reason or message and return a\n     * consistent error object.\n     *\n     * @param {Object|String} response\n     *        Response (Object) or status (String) to be transformed.\n     * @param {String} [message=null]\n     *        Error message.\n     *\n     * @returns {GeoError}\n     *          `GeoError` instance if response contains an error. Otherwise,\n     *          returns `null`.\n     *\n     * @example\n     * var error = geolocator.Error.fromResponse(googleResponse);\n     * console.log(error.code); // \"GOOGLE_KEY_INVALID\"\n     */\n    static fromResponse(response, message = '') {\n        // example Google Geolocation API response:\n        // https://developers.google.com/maps/documentation/geolocation/intro#errors\n        // {\n        //      \"error\": {\n        //          \"errors\": [\n        //              {\n        //                  \"domain\": \"global\",\n        //                  \"reason\": \"parseError\",\n        //                  \"message\": \"Parse Error\",\n        //              }\n        //          ],\n        //      \"code\": 400,\n        //      \"message\": \"Parse Error\"\n        //      }\n        // }\n        // example Google TimeZone API response:\n        // {\n        //     \"status\": \"REQUEST_DENIED\"\n        // }\n\n        if (!response) return new GeoError(GeoError.Code.INVALID_RESPONSE);\n\n        let errCode;\n\n        if (utils.isString(response)) {\n            errCode = errorCodeFromStatus(response);\n            if (errCode) return new GeoError(errCode, message || response);\n        }\n\n        if (!utils.isObject(response)) return null;\n\n        let errMsg = response.error_message\n            || response.errorMessage\n            || ((response.error && response.error.message) || '')\n            || '';\n\n        if (response.status) {\n            errCode = errorCodeFromStatus(response.status);\n            if (errCode) return new GeoError(errCode, errMsg || message || response.status);\n        }\n\n        if (response.error) {\n            let reason = response.reason || response.error.reason;\n            if (!reason) {\n                let errors = response.error.errors;\n                if (utils.isArray(errors) && errors.length > 0) {\n                    reason = errors[0].reason; // get the first reason only\n                    errMsg = errMsg || errors[0].message; // update errMsg\n                }\n            }\n            errCode = errorCodeFromReason(reason) || GeoError.Code.UNKNOWN_ERROR;\n            return new GeoError(errCode, errMsg || reason || message);\n        }\n\n        if (errMsg) {\n            errCode = errorCodeFromStatus(errMsg) || GeoError.Code.UNKNOWN_ERROR;\n            return new GeoError(errCode, errMsg || message);\n        }\n\n        return null;\n    }\n\n    /**\n     *  Checks whether the given value is an instance of `GeoError`.\n     *\n     *  @param {*} err - Object to be checked.\n     *\n     *  @returns {Boolean}\n     */\n    static isGeoError(err) {\n        return err instanceof GeoError;\n    }\n\n    /**\n     *  Checks whether the given value is a valid Geolocator Error code.\n     *\n     *  @param {String} errorCode - Error code to be checked.\n     *\n     *  @returns {Boolean}\n     */\n    static isValidErrorCode(errorCode) {\n        let prop;\n        for (prop in GeoError.Code) {\n            if (GeoError.Code.hasOwnProperty(prop)\n                    && errorCode === GeoError.Code[prop]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n *  Gets the string representation of the error instance.\n *\n *  @returns {String}\n */\nGeoError.prototype.toString = function () {\n    var msg = this.code !== this.message ? ` (${this.message})` : '';\n    return `${this.name}: ${this.code}${msg}`;\n};\n\n// `class x extends Error` doesn't work when using an ES6 transpiler, such as\n// Babel, since subclasses must extend a class. With Babel 6, we need\n// transform-builtin-extend plugin for this to work. So we're extending from\n// Error the old way. Now, `err instanceof Error` also returns `true`.\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(GeoError.prototype, Error.prototype);\n} else {\n    GeoError.prototype = Object.create(Error.prototype);\n}\n\n// ---------------------------\n// ERROR CODES\n// ---------------------------\n\n/**\n *  Enumerates Geolocator error codes.\n *  This enumeration combines Google API status (error) codes, HTML5 Geolocation\n *  position error codes and other Geolocator-specific error codes.\n *  @enum {String}\n */\nGeoError.Code = {\n    /**\n     *  Indicates that HTML5 Geolocation API is not supported by the browser.\n     *  @type {String}\n     */\n    GEOLOCATION_NOT_SUPPORTED: 'GEOLOCATION_NOT_SUPPORTED',\n    /**\n     *  Indicates that Geolocation-IP source is not set or invalid.\n     *  @type {String}\n     */\n    INVALID_GEO_IP_SOURCE: 'INVALID_GEO_IP_SOURCE',\n    /**\n     *  The acquisition of the geolocation information failed because the\n     *  page didn't have the permission to do it.\n     *  @type {String}\n     */\n    PERMISSION_DENIED: 'PERMISSION_DENIED',\n    /**\n     *  The acquisition of the geolocation failed because at least one\n     *  internal source of position returned an internal error.\n     *  @type {String}\n     */\n    POSITION_UNAVAILABLE: 'POSITION_UNAVAILABLE',\n    /**\n     *  The time allowed to acquire the geolocation, defined by\n     *  PositionOptions.timeout information was reached before\n     *  the information was obtained.\n     *  @type {String}\n     */\n    TIMEOUT: 'TIMEOUT',\n    /**\n     * Indicates that the request had one or more invalid parameters.\n     * @type {String}\n     */\n    INVALID_PARAMETERS: 'INVALID_PARAMETERS',\n    /**\n     * Indicates that the service returned invalid response.\n     * @type {String}\n     */\n    INVALID_RESPONSE: 'INVALID_RESPONSE',\n    /**\n     * Generally indicates that the query (address, components or latlng)\n     * is missing.\n     * @type {String}\n     */\n    INVALID_REQUEST: 'INVALID_REQUEST',\n    /**\n     * Indicates that the request was denied by the service.\n     * This will generally occur because of a missing API key or because the request\n     * is sent over HTTP instead of HTTPS.\n     * @type {String}\n     */\n    REQUEST_DENIED: 'REQUEST_DENIED',\n    /**\n     * Indicates that the request has failed.\n     * This will generally occur because of an XHR error.\n     * @type {String}\n     */\n    REQUEST_FAILED: 'REQUEST_FAILED',\n    /**\n     * Indicates that Google API could not be loaded.\n     * @type {String}\n     */\n    GOOGLE_API_FAILED: 'GOOGLE_API_FAILED',\n    /**\n     * Indicates that you are over your Google API quota.\n     * @type {String}\n     */\n    OVER_QUERY_LIMIT: 'OVER_QUERY_LIMIT',\n    /**\n     * Indicates that you've exceeded the requests per second per user limit that\n     * you configured in the Google Developers Console. This limit should be\n     * configured to prevent a single or small group of users from exhausting your\n     * daily quota, while still allowing reasonable access to all users.\n     * @type {String}\n     */\n    USER_RATE_LIMIT_EXCEEDED: 'USER_RATE_LIMIT_EXCEEDED',\n    /**\n     * Indicates that you've exceeded your daily limit for Google API(s).\n     * @type {String}\n     */\n    DAILY_LIMIT_EXCEEDED: 'DAILY_LIMIT_EXCEEDED',\n    /**\n     * Indicates that your Google API key is not valid. Please ensure that you've\n     * included the entire key, and that you've either purchased the API or have\n     * enabled billing and activated the API to obtain the free quota.\n     * @type {String}\n     */\n    GOOGLE_KEY_INVALID: 'GOOGLE_KEY_INVALID',\n    /**\n     * Indicates that maximum number of elements limit is exceeded. For\n     * example, for the Distance Matrix API; occurs when the product of\n     * origins and destinations exceeds the per-query limit.\n     * @type {String}\n     */\n    MAX_ELEMENTS_EXCEEDED: 'MAX_ELEMENTS_EXCEEDED',\n    /**\n     * Indicates that the request contained more than 25 origins,\n     * or more than 25 destinations.\n     * @type {String}\n     */\n    MAX_DIMENSIONS_EXCEEDED: 'MAX_DIMENSIONS_EXCEEDED',\n    /**\n     * Indicates that the request contained more than allowed waypoints.\n     * @type {String}\n     */\n    MAX_WAYPOINTS_EXCEEDED: 'MAX_WAYPOINTS_EXCEEDED',\n    /**\n     * Indicates that the request body is not valid JSON.\n     * @type {String}\n     */\n    PARSE_ERROR: 'PARSE_ERROR',\n    /**\n     * Indicates that the requested resource could not be found.\n     * Note that this also covers `ZERO_RESULTS`.\n     * @type {String}\n     */\n    NOT_FOUND: 'NOT_FOUND',\n    /**\n     * Indicates that an internal error (such as XHR cross-domain, etc) has occured.\n     * @type {String}\n     */\n    INTERNAL_ERROR: 'INTERNAL_ERROR',\n    /**\n     * Indicates that an unknown error has occured.\n     * @type {String}\n     */\n    UNKNOWN_ERROR: 'UNKNOWN_ERROR'\n};\n\n// ---------------------------\n// HELPER METHODS\n// ---------------------------\n\n/**\n *  @private\n */\nfunction errorCodeFromStatus(status) {\n    if (!status) return GeoError.Code.INVALID_RESPONSE;\n    if (status === 'OK') return null;\n    if (status === 'ZERO_RESULTS') return GeoError.Code.NOT_FOUND;\n    if (GeoError.Code.hasOwnProperty(status)) return status;\n    return null;\n}\n\n/**\n *  Gets `GeoError.Code` from the given response error reason.\n *  @private\n *\n *  @param {String} reason\n *         Google response error reason.\n *\n *  @returns {String}\n */\nfunction errorCodeFromReason(reason) {\n    switch (reason) {\n        case 'invalid':\n            return GeoError.Code.INVALID_REQUEST;\n        case 'dailyLimitExceeded':\n            return GeoError.Code.DAILY_LIMIT_EXCEEDED;\n        case 'keyInvalid':\n            return GeoError.Code.GOOGLE_KEY_INVALID;\n        case 'userRateLimitExceeded':\n            return GeoError.Code.USER_RATE_LIMIT_EXCEEDED;\n        case 'notFound':\n            return GeoError.Code.NOT_FOUND;\n        case 'parseError':\n            return GeoError.Code.PARSE_ERROR;\n        default:\n            return null;\n    }\n}\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexport default GeoError;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/geo.error.js\n **/","/* eslint no-nested-ternary:0 */\n\nimport utils from '../lib/utils';\n\nclass GeoWatcher {\n\n    constructor(onChange, onError, options = {}) {\n        this.isCleared = false;\n        this.cycle = 0;\n        this._timer = null;\n        this.id = navigator.geolocation.watchPosition(\n            pos => {\n                this.cycle++;\n                if (utils.isFunction(onChange)) onChange(pos);\n            },\n            err => {\n                this.cycle++;\n                if (utils.isFunction(onError)) onError(err);\n                if (options.clearOnError) {\n                    this.clear();\n                }\n            },\n            options\n        );\n    }\n\n    _clear() {\n        navigator.geolocation.clearWatch(this.id);\n        this.isCleared = true;\n        this._timer = null;\n    }\n\n    clear(delay, callback) {\n        let d = utils.isNumber(delay) ? delay : 0,\n            cb = utils.isFunction(callback) ? callback\n                : utils.isFunction(delay) ? delay : null;\n        // clear any previous timeout\n        if (this._timer) {\n            clearTimeout(this._timer);\n            this._timer = null;\n        }\n        // check if watcher is not cleared\n        if (!this.isCleared) {\n            if (d === 0) {\n                this._clear();\n                if (cb) cb();\n                return;\n            }\n            this._timer = setTimeout(() => {\n                this._clear();\n                if (cb) cb();\n            }, d);\n        }\n    }\n\n}\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexport default GeoWatcher;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/geo.watcher.js\n **/"],"sourceRoot":""}